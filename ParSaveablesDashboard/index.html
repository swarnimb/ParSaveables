<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ParSaveables</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Rajdhani', 'Orbitron', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1d35 25%, #2d1b3d 50%, #1a1d35 75%, #0a0e27 100%);
            background-attachment: fixed;
            min-height: 100vh;
            padding: 20px;
            color: #ffffff;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    rgba(255, 0, 100, 0.03) 2px,
                    rgba(255, 0, 100, 0.03) 4px
                );
            pointer-events: none;
            z-index: 1;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 2;
        }
        
        header {
            text-align: center;
            color: #ffffff;
            margin-bottom: 30px;
            position: relative;
            background: linear-gradient(135deg, rgba(255, 0, 100, 0.15) 0%, rgba(255, 102, 0, 0.15) 50%, rgba(255, 215, 0, 0.15) 100%);
            padding: 30px;
            border-radius: 20px;
            box-shadow:
                0 0 60px rgba(255, 0, 100, 0.3),
                0 0 30px rgba(255, 102, 0, 0.2),
                0 8px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            background-clip: padding-box;
            backdrop-filter: blur(20px);
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #ff0064, #ff6600, #ffd700, #ff6600, #ff0064);
            background-size: 400% 400%;
            border-radius: 20px;
            z-index: -1;
            animation: gradientShift 3s ease infinite;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        .logo-container {
            display: inline-block;
            position: relative;
            margin-bottom: 15px;
        }
        
        .logo {
            width: 80px;
            height: 80px;
            filter: drop-shadow(0 4px 8px rgba(100, 255, 218, 0.4));
        }
        
        header h1 {
            font-size: 3.5em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #cc5577 0%, #dd8822 25%, #eebb00 50%, #dd8822 75%, #cc5577 100%);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            -webkit-text-stroke: 1.5px rgba(255, 255, 255, 0.4);
            font-weight: 700;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            text-transform: uppercase;
            animation: shine 3s linear infinite;
            filter: drop-shadow(0 0 15px rgba(255, 238, 68, 0.6));
        }

        @keyframes shine {
            to { background-position: 200% center; }
        }
        
        
        .pun-banner {
            background: linear-gradient(135deg, rgba(255, 165, 0, 0.95) 0%, rgba(255, 140, 0, 0.95) 100%);
            backdrop-filter: blur(10px);
            border-left: 6px solid #ff6600;
            border-radius: 12px;
            padding: 16px 20px;
            margin: 20px auto 25px;
            max-width: 800px;
            box-shadow:
                0 4px 20px rgba(255, 140, 0, 0.4),
                0 0 40px rgba(255, 165, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            gap: 15px;
            animation: slideDown 0.6s ease-out;
            position: relative;
            overflow: hidden;
        }

        .pun-banner::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 3s infinite;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 200%; }
        }

        .pun-icon {
            font-size: 2em;
            flex-shrink: 0;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
            animation: bounce 2s ease-in-out infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        .pun-text {
            flex: 1;
            color: #000;
            font-size: 1.1em;
            font-weight: 700;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
            letter-spacing: 0.5px;
            line-height: 1.4;
            position: relative;
            z-index: 1;
        }

        .pun-refresh {
            background: rgba(0, 0, 0, 0.2);
            border: none;
            color: #fff;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            transition: all 0.3s ease;
            flex-shrink: 0;
            position: relative;
            z-index: 1;
        }

        .pun-refresh:hover {
            background: rgba(0, 0, 0, 0.3);
            transform: rotate(180deg);
        }

        .chat-section {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(250, 250, 252, 0.95) 100%);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.08);
            margin-bottom: 25px;
            margin-top: 5px;
            margin-left: auto;
            margin-right: auto;
            max-width: 800px;
            transition: all 0.3s ease;
            min-height: auto;
            display: flex;
            flex-direction: column;
        }

        .chat-section.expanded {
            padding: 20px;
            min-height: 450px;
        }

        .chat-box {
            height: 0;
            overflow: hidden;
            border: 1px solid rgba(100, 255, 218, 0.2);
            border-radius: 10px;
            padding: 0;
            margin-bottom: 0;
            background: rgba(10, 25, 47, 0.6);
            transition: all 0.3s ease;
        }

        .chat-box.visible {
            height: 350px;
            overflow-y: auto;
            padding: 10px;
            margin-bottom: 10px;
        }
        
        .message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            max-width: 80%;
            animation: fadeIn 0.3s;
            font-size: 0.9em;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .user-message {
            background: linear-gradient(135deg, #64ffda 0%, #00d9ff 100%);
            color: #0a192f;
            margin-left: auto;
            text-align: right;
            font-weight: 500;
        }
        
        .bot-message {
            background: rgba(100, 255, 218, 0.1);
            border: 1px solid rgba(100, 255, 218, 0.2);
            color: #e6f1ff;
            white-space: pre-wrap;
        }
        
        .chat-input-container {
            display: flex;
            gap: 8px;
        }
        
        #chatInput {
            flex: 1;
            padding: 10px;
            border: 1px solid rgba(100, 255, 218, 0.3);
            border-radius: 8px;
            font-size: 0.9em;
            background: rgba(10, 25, 47, 0.6);
            color: #e6f1ff;
        }
        
        #chatInput::placeholder {
            color: rgba(230, 241, 255, 0.5);
        }
        
        #sendBtn {
            background: linear-gradient(135deg, #64ffda 0%, #00d9ff 100%);
            color: #0a192f;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        #sendBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(100, 255, 218, 0.4);
        }
        
        #sendBtn:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }
        
        .row {
            margin-bottom: 20px;
        }
        
        .row-1 {
            display: grid;
            grid-template-columns: 1fr;
        }
        
        .row-2 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .row-3 {
            display: grid;
            grid-template-columns: 1fr;
        }
        
        .card {
            background: linear-gradient(135deg, rgba(20, 25, 45, 0.95) 0%, rgba(30, 20, 40, 0.95) 100%);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 24px;
            box-shadow:
                0 0 40px rgba(255, 0, 100, 0.2),
                0 0 20px rgba(255, 102, 0, 0.1),
                0 8px 32px rgba(0, 0, 0, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 102, 0, 0.3);
            min-height: 450px;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.1), transparent);
            transition: left 1.5s;
        }

        .card:hover::before {
            left: 100%;
        }
        
        .card h2 {
            color: #ffd700;
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 2px solid rgba(255, 102, 0, 0.4);
            padding-bottom: 12px;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            position: relative;
            z-index: 1;
        }

        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
        }

        .scrollable-table {
            max-height: 350px;
            overflow-y: auto;
            overflow-x: auto;
            border-radius: 8px;
            flex-grow: 1;
        }
        
        .scrollable-table::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        .scrollable-table::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
        }

        .scrollable-table::-webkit-scrollbar-thumb {
            background: rgba(0, 102, 204, 0.3);
            border-radius: 4px;
        }

        .scrollable-table::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 102, 204, 0.5);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            min-width: 500px;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 102, 0, 0.2);
        }

        th {
            background: linear-gradient(135deg, rgba(255, 0, 100, 0.95) 0%, rgba(255, 102, 0, 0.95) 100%);
            backdrop-filter: blur(10px);
            font-weight: 600;
            color: #ffd700;
            position: sticky;
            top: 0;
            z-index: 10;
            white-space: nowrap;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
        }

        td {
            font-size: 0.9em;
            color: #ffffff;
        }

        tr:hover {
            background: rgba(255, 102, 0, 0.1);
            transform: scale(1.01);
            transition: all 0.2s ease;
        }
        
        .rank-badge {
            display: inline-block;
            width: 30px;
            height: 30px;
            line-height: 30px;
            text-align: center;
            border-radius: 50%;
            font-weight: bold;
        }
        
        .rank-1 {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 50%, #FFD700 100%);
            color: #000;
            box-shadow:
                0 0 20px rgba(255, 215, 0, 0.8),
                0 0 40px rgba(255, 215, 0, 0.4),
                inset 0 0 10px rgba(255, 255, 255, 0.5);
            font-weight: 900;
            animation: pulse 2s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .rank-2 {
            background: linear-gradient(135deg, #E8E8E8 0%, #C0C0C0 50%, #E8E8E8 100%);
            color: #000;
            box-shadow:
                0 0 15px rgba(192, 192, 192, 0.6),
                inset 0 0 8px rgba(255, 255, 255, 0.4);
            font-weight: 800;
        }
        .rank-3 {
            background: linear-gradient(135deg, #E39A5A 0%, #CD7F32 50%, #E39A5A 100%);
            color: #fff;
            box-shadow:
                0 0 15px rgba(205, 127, 50, 0.6),
                inset 0 0 8px rgba(255, 255, 255, 0.3);
            font-weight: 800;
        }
        .rank-other {
            background: linear-gradient(135deg, rgba(255, 0, 100, 0.3) 0%, rgba(255, 102, 0, 0.3) 100%);
            color: #ffd700;
            border: 1px solid rgba(255, 102, 0, 0.5);
        }
        
        .bar-container {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }
        
        .player-name {
            min-width: 120px;
            font-weight: 600;
            color: #64ffda;
        }
        
        .bars {
            display: flex;
            flex: 1;
            gap: 2px;
            height: 25px;
        }
        
        .bar {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.8em;
            font-weight: bold;
            border-radius: 3px;
        }
        
        .bar-ace { background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); }
        .bar-eagle { background: linear-gradient(135deg, #f39c12 0%, #d68910 100%); }
        .bar-birdie { background: linear-gradient(135deg, #27ae60 0%, #229954 100%); }
        
        .legend {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            font-size: 0.9em;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
        }
        
        .loading {
            text-align: center;
            color: #64ffda;
            padding: 20px;
        }

        /* Podcast Modal Styles */
        .podcast-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 39, 0.95);
            backdrop-filter: blur(10px);
            animation: fadeIn 0.3s ease;
        }

        .podcast-modal-content {
            position: relative;
            background: linear-gradient(135deg, rgba(20, 25, 45, 0.95) 0%, rgba(30, 20, 40, 0.95) 100%);
            margin: 5% auto;
            padding: 30px;
            border: 2px solid #64ffda;
            border-radius: 20px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 40px rgba(100, 255, 218, 0.5), 0 0 80px rgba(0, 204, 255, 0.3);
            animation: slideIn 0.4s ease;
        }

        .podcast-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(100, 255, 218, 0.3);
        }

        .podcast-modal-header h2 {
            color: #64ffda;
            margin: 0;
            font-size: 1.6em;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .close-modal {
            color: #ff6699;
            font-size: 2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            line-height: 1;
        }

        .close-modal:hover {
            color: #ffee44;
            transform: rotate(90deg);
            text-shadow: 0 0 20px rgba(255, 238, 68, 0.8);
        }

        .podcast-episode {
            background: rgba(20, 25, 45, 0.6);
            padding: 20px;
            margin: 15px 0;
            border-radius: 15px;
            border: 1px solid rgba(100, 255, 218, 0.2);
            transition: all 0.3s;
        }

        .podcast-episode:hover {
            border-color: #64ffda;
            box-shadow: 0 0 20px rgba(100, 255, 218, 0.3);
            transform: translateX(5px);
        }

        .podcast-episode-title {
            color: #ffd700;
            font-size: 1.1em;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .podcast-episode-meta {
            color: #64ffda;
            font-size: 0.9em;
            margin-bottom: 15px;
            opacity: 0.8;
        }

        .podcast-play-btn {
            padding: 10px 25px;
            background: linear-gradient(135deg, #0066ff 0%, #00ccff 100%);
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .podcast-play-btn:hover {
            box-shadow: 0 0 25px rgba(0, 204, 255, 0.6);
            transform: scale(1.05);
        }

        .podcast-audio-player {
            margin-top: 15px;
            width: 100%;
        }

        .podcast-loading {
            text-align: center;
            color: #64ffda;
            font-size: 1.2em;
            padding: 40px;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            header h1 {
                font-size: 1.8em;
            }

            .logo {
                width: 60px;
                height: 60px;
            }

            .pun-banner {
                padding: 12px 15px;
                gap: 10px;
            }

            .pun-icon {
                font-size: 1.5em;
            }

            .pun-text {
                font-size: 0.95em;
            }

            .pun-refresh {
                width: 32px;
                height: 32px;
                font-size: 1em;
            }

            .row-2 {
                grid-template-columns: 1fr;
            }

            .card {
                padding: 15px;
            }

            .card h2 {
                font-size: 1.1em;
            }

            table {
                font-size: 0.85em;
            }

            th, td {
                padding: 8px;
            }

            .player-name {
                min-width: 80px;
                font-size: 0.85em;
            }

            .chat-box.visible {
                height: 120px;
            }

            /* Fix mobile line graph height */
            .chart-container {
                height: 300px !important;
            }
        }
        
        @media (max-width: 480px) {
            header h1 {
                font-size: 2.5em;
            }

            .pun-banner {
                padding: 10px 12px;
            }

            .pun-text {
                font-size: 0.85em;
            }

            table {
                font-size: 0.75em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo-container">
                <svg class="logo" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <ellipse cx="50" cy="70" rx="25" ry="8" fill="#444" opacity="0.6"/>
                    <rect x="48" y="30" width="4" height="40" fill="#666"/>
                    <circle cx="50" cy="30" r="2" fill="#888"/>
                    <line x1="35" y1="35" x2="35" y2="65" stroke="#888" stroke-width="1"/>
                    <line x1="42" y1="32" x2="42" y2="65" stroke="#888" stroke-width="1"/>
                    <line x1="50" y1="30" x2="50" y2="65" stroke="#888" stroke-width="1"/>
                    <line x1="58" y1="32" x2="58" y2="65" stroke="#888" stroke-width="1"/>
                    <line x1="65" y1="35" x2="65" y2="65" stroke="#888" stroke-width="1"/>
                    <g transform="translate(50, 15) rotate(15) translate(-50, -15)">
                        <path d="M 35 20 L 40 10 L 45 20 L 50 8 L 55 20 L 60 10 L 65 20 L 65 28 L 35 28 Z" 
                              fill="#64ffda" stroke="#00a896" stroke-width="1.5"/>
                        <circle cx="40" cy="10" r="2" fill="#ff6b6b"/>
                        <circle cx="50" cy="8" r="2.5" fill="#ff6b6b"/>
                        <circle cx="60" cy="10" r="2" fill="#ff6b6b"/>
                    </g>
                </svg>
            </div>
            <h1>
                <svg width="60" height="60" viewBox="0 0 100 100" style="flex-shrink: 0; filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.8));">
                    <!-- Pole -->
                    <rect x="48" y="10" width="4" height="80" fill="url(#poleGradient)"/>
                    <defs>
                        <linearGradient id="poleGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#ffd700;stop-opacity:1" />
                            <stop offset="50%" style="stop-color:#ff6600;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#ff0064;stop-opacity:1" />
                        </linearGradient>
                        <linearGradient id="basketGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                            <stop offset="0%" style="stop-color:#ff0064;stop-opacity:1" />
                            <stop offset="50%" style="stop-color:#ff6600;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#ffd700;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <!-- Base -->
                    <ellipse cx="50" cy="90" rx="15" ry="3" fill="#ff6600"/>
                    <!-- Basket rim -->
                    <ellipse cx="50" cy="25" rx="20" ry="4" fill="url(#basketGradient)"/>
                    <!-- Chains (3 sets) with glow -->
                    <line x1="40" y1="25" x2="40" y2="60" stroke="#ffd700" stroke-width="2"/>
                    <line x1="45" y1="25" x2="45" y2="62" stroke="#ff6600" stroke-width="2"/>
                    <line x1="50" y1="25" x2="50" y2="64" stroke="#ff0064" stroke-width="2"/>
                    <line x1="55" y1="25" x2="55" y2="62" stroke="#ff6600" stroke-width="2"/>
                    <line x1="60" y1="25" x2="60" y2="60" stroke="#ffd700" stroke-width="2"/>
                    <!-- Bottom basket -->
                    <path d="M 30 60 Q 50 75 70 60" fill="none" stroke="url(#basketGradient)" stroke-width="3"/>
                    <ellipse cx="50" cy="60" rx="20" ry="3" fill="url(#basketGradient)"/>
                </svg>
                ParSaveables
                <svg width="60" height="60" viewBox="0 0 100 100" style="flex-shrink: 0; filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.8));">
                    <!-- Pole -->
                    <rect x="48" y="10" width="4" height="80" fill="url(#poleGradient2)"/>
                    <defs>
                        <linearGradient id="poleGradient2" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#ffd700;stop-opacity:1" />
                            <stop offset="50%" style="stop-color:#ff6600;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#ff0064;stop-opacity:1" />
                        </linearGradient>
                        <linearGradient id="basketGradient2" x1="0%" y1="0%" x2="100%" y2="0%">
                            <stop offset="0%" style="stop-color:#ff0064;stop-opacity:1" />
                            <stop offset="50%" style="stop-color:#ff6600;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#ffd700;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <!-- Base -->
                    <ellipse cx="50" cy="90" rx="15" ry="3" fill="#ff6600"/>
                    <!-- Basket rim -->
                    <ellipse cx="50" cy="25" rx="20" ry="4" fill="url(#basketGradient2)"/>
                    <!-- Chains (3 sets) with glow -->
                    <line x1="40" y1="25" x2="40" y2="60" stroke="#ffd700" stroke-width="2"/>
                    <line x1="45" y1="25" x2="45" y2="62" stroke="#ff6600" stroke-width="2"/>
                    <line x1="50" y1="25" x2="50" y2="64" stroke="#ff0064" stroke-width="2"/>
                    <line x1="55" y1="25" x2="55" y2="62" stroke="#ff6600" stroke-width="2"/>
                    <line x1="60" y1="25" x2="60" y2="60" stroke="#ffd700" stroke-width="2"/>
                    <!-- Bottom basket -->
                    <path d="M 30 60 Q 50 75 70 60" fill="none" stroke="url(#basketGradient2)" stroke-width="3"/>
                    <ellipse cx="50" cy="60" rx="20" ry="3" fill="url(#basketGradient2)"/>
                </svg>
            </h1>

            <!-- Podcast Button (Top Right) -->
            <button id="podcastsBtn" onclick="openPodcastModal()" style="position: absolute; top: 20px; right: 20px; padding: 12px; font-size: 1.8em; border-radius: 50%; border: 2px solid #64ffda; background: linear-gradient(135deg, #0066ff 0%, #00ccff 100%); color: white; cursor: pointer; transition: all 0.3s; box-shadow: 0 0 20px rgba(0, 204, 255, 0.6); width: 60px; height: 60px; display: flex; align-items: center; justify-content: center;">
                üéôÔ∏è
            </button>

            <!-- Tab Navigation -->
            <div style="margin: 20px 0; display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
                <button id="seasonsTab" onclick="switchTab('seasons')" style="padding: 14px 36px; font-size: 1.1em; border-radius: 12px; border: 2px solid #ff6600; background: linear-gradient(135deg, #ff0064 0%, #ff6600 100%); color: white; cursor: pointer; font-weight: 700; transition: all 0.3s; box-shadow: 0 0 20px rgba(255, 102, 0, 0.6), 0 0 40px rgba(255, 0, 100, 0.3); text-transform: uppercase; letter-spacing: 1px;">
                    Seasons
                </button>
                <button id="tournamentsTab" onclick="switchTab('tournaments')" style="padding: 14px 36px; font-size: 1.1em; border-radius: 12px; border: 2px solid rgba(255, 102, 0, 0.4); background: rgba(20, 25, 45, 0.8); color: #ffd700; cursor: pointer; font-weight: 700; transition: all 0.3s; text-transform: uppercase; letter-spacing: 1px;">
                    Tournaments
                </button>
            </div>

            <!-- Event Selector -->
            <div style="margin: 15px 0;">
                <label for="eventSelect" id="eventLabel" style="font-size: 1.1em; margin-right: 10px; color: #ffd700; font-weight: 600; text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);">Season:</label>
                <select id="eventSelect" onchange="loadAllData()" style="padding: 10px 20px; font-size: 1em; border-radius: 10px; background: linear-gradient(135deg, rgba(20, 25, 45, 0.9) 0%, rgba(30, 20, 40, 0.9) 100%); color: #ffd700; border: 2px solid rgba(255, 102, 0, 0.5); cursor: pointer; font-weight: 600; box-shadow: 0 0 15px rgba(255, 102, 0, 0.3);">
                    <!-- Options will be populated dynamically -->
                </select>
            </div>
        </header>

        <!-- Podcast Modal -->
        <div id="podcastModal" class="podcast-modal" onclick="closePodcastModal(event)">
            <div class="podcast-modal-content" onclick="event.stopPropagation()">
                <div class="podcast-modal-header">
                    <h2>üéôÔ∏è Chain Reactions Podcast</h2>
                    <span class="close-modal" onclick="closePodcastModal()">&times;</span>
                </div>
                <div id="podcastList" class="podcast-loading">
                    Loading podcasts...
                </div>
            </div>
        </div>

        <!-- Pun Banner -->
        <div class="pun-banner" id="punBanner">
            <div class="pun-icon" id="punIcon">‚ö†Ô∏è</div>
            <div class="pun-text" id="punText">Loading pun...</div>
            <button class="pun-refresh" onclick="refreshPun()" title="Get another pun">üîÑ</button>
        </div>

        <div class="chat-section" id="chatSection">
            <div class="chat-box" id="chatBox"></div>
            <div class="chat-input-container">
                <input type="text" id="chatInput" placeholder="Ask a question about stats..." onkeypress="handleKeyPress(event)">
                <button id="sendBtn" onclick="sendMessage()">Send</button>
            </div>
        </div>

        <div class="row row-1">
            <div class="card">
                <h2 id="leaderboardTitle">üèÜ Season Leaderboard</h2>
                <div class="scrollable-table">
                    <div id="leaderboard" class="loading">Loading...</div>
                </div>
            </div>
        </div>

        <div class="row row-2">
            <div class="card">
                <h2>üéØ Aces/Eagles/Birdies</h2>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color bar-ace"></div>
                        <span>Aces</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color bar-eagle"></div>
                        <span>Eagles</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color bar-birdie"></div>
                        <span>Birdies</span>
                    </div>
                </div>
                <div class="scrollable-table">
                    <div id="birdieLeaders" class="loading">Loading...</div>
                </div>
            </div>

            <div class="card">
                <h2 id="coursesTableTitle">üèûÔ∏è Average Score by Course Tiers</h2>
                <div class="scrollable-table">
                    <div id="coursesTable" class="loading">Loading...</div>
                </div>
            </div>
        </div>

        <div class="row row-3">
            <div class="card">
                <h2 id="trendChartTitle">üìà Monthly Points Trend</h2>
                <div class="chart-container">
                    <canvas id="monthlyTrendChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        const SUPABASE_URL = 'https://bcovevbtcdsgzbrieiin.supabase.co';  // e.g., 'https://xxxxx.supabase.co'
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJjb3ZldmJ0Y2RzZ3picmllaWluIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA2MzA3OTEsImV4cCI6MjA3NjIwNjc5MX0.etzrLL8yw4n_NUdYnr_bdcrKphW67dYln8CjR54NSLA';  // Long string starting with 'eyJ...'
        const N8N_CHATBOT_URL = 'https://parsaveables-seasons.onrender.com/webhook/chatbot';  // e.g., 'http://localhost:5678/webhook/chatbot'

        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
        let monthlyTrendChart;
        let availableSeasons = [];
        let currentTab = 'seasons'; // Track current tab
        let availableEvents = []; // Store all events

        // Registered players list
        const REGISTERED_PLAYERS = [
            'Intern Line Cook',
            'Jabba the Putt',
            'Food Zaddy',
            'Jaguar',
            'Shogun',
            'BigBirdie',
            'Butter Cookie',
            'Cobra',
            'Bird',
            'Fireball',
            'Ace Brook',
            'ScarletSpeedster'
        ];

        // Display name mapper - converts database names to display names
        function getDisplayName(dbName) {
            if (dbName === 'Bird') return 'ü¶Ö';
            return dbName;
        }

        // Check if a player name is registered (case-insensitive)
        function isRegisteredPlayer(playerName) {
            return REGISTERED_PLAYERS.some(registeredName =>
                registeredName.toLowerCase() === playerName.toLowerCase()
            );
        }

        // Get the canonical registered player name (with correct casing)
        function getCanonicalPlayerName(playerName) {
            const match = REGISTERED_PLAYERS.find(registeredName =>
                registeredName.toLowerCase() === playerName.toLowerCase()
            );
            return match || playerName;
        }

        // Podcast Modal Functions
        let currentAudio = null;

        function openPodcastModal() {
            document.getElementById('podcastModal').style.display = 'block';
            loadPodcasts();
        }

        function closePodcastModal(event) {
            // Close only if clicking outside or on close button
            if (!event || event.target.id === 'podcastModal' || event.target.className === 'close-modal') {
                document.getElementById('podcastModal').style.display = 'none';
                // Stop any playing audio
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio = null;
                }
            }
        }

        async function loadPodcasts() {
            const podcastList = document.getElementById('podcastList');
            podcastList.innerHTML = '<div class="podcast-loading">Loading podcasts...</div>';

            try {
                // Fetch releases from GitHub
                const response = await fetch('https://api.github.com/repos/swarnimb/ParSaveables/releases');

                if (!response.ok) {
                    throw new Error('Failed to fetch podcasts');
                }

                const releases = await response.json();

                // Filter releases that have audio files
                const podcastReleases = releases.filter(release =>
                    release.assets && release.assets.some(asset => asset.name.endsWith('.mp3'))
                );

                if (podcastReleases.length === 0) {
                    podcastList.innerHTML = '<div class="podcast-loading">No podcasts available yet. Check back soon!</div>';
                    return;
                }

                // Display podcasts
                podcastList.innerHTML = '';
                podcastReleases.forEach((release, index) => {
                    const audioAsset = release.assets.find(asset => asset.name.endsWith('.mp3'));
                    if (audioAsset) {
                        const episodeDiv = createPodcastEpisode(release, audioAsset, index + 1);
                        podcastList.appendChild(episodeDiv);
                    }
                });

            } catch (error) {
                console.error('Error loading podcasts:', error);
                podcastList.innerHTML = '<div class="podcast-loading" style="color: #ff6699;">Failed to load podcasts. Please try again later.</div>';
            }
        }

        function createPodcastEpisode(release, audioAsset, episodeNumber) {
            const episodeDiv = document.createElement('div');
            episodeDiv.className = 'podcast-episode';

            // Episode title
            const title = document.createElement('div');
            title.className = 'podcast-episode-title';
            title.textContent = release.name || `Episode ${episodeNumber}`;

            // Meta info with duration estimate
            const meta = document.createElement('div');
            meta.className = 'podcast-episode-meta';
            const fileSize = (audioAsset.size / (1024 * 1024)).toFixed(1);
            // Estimate duration: ~1MB per minute for 128kbps MP3
            const estimatedDuration = Math.round(fileSize);
            meta.textContent = `‚è±Ô∏è ${estimatedDuration} min`;

            // Play button
            const playBtn = document.createElement('button');
            playBtn.className = 'podcast-play-btn';
            playBtn.textContent = '‚ñ∂Ô∏è Play';
            playBtn.onclick = () => playPodcast(audioAsset.browser_download_url, episodeDiv, playBtn);

            episodeDiv.appendChild(title);
            episodeDiv.appendChild(meta);
            episodeDiv.appendChild(playBtn);

            return episodeDiv;
        }

        function playPodcast(audioUrl, episodeDiv, playBtn) {
            // Stop any currently playing audio
            if (currentAudio) {
                currentAudio.pause();
                // Reset previous play button
                const prevBtns = document.querySelectorAll('.podcast-play-btn');
                prevBtns.forEach(btn => {
                    btn.textContent = '‚ñ∂Ô∏è Play';
                    btn.style.background = 'linear-gradient(135deg, #0066ff 0%, #00ccff 100%)';
                });
                // Remove previous audio players
                document.querySelectorAll('.podcast-audio-player').forEach(player => player.remove());
            }

            // Check if clicking same button
            if (currentAudio && currentAudio.src === audioUrl && !currentAudio.paused) {
                currentAudio.pause();
                playBtn.textContent = '‚ñ∂Ô∏è Play';
                playBtn.style.background = 'linear-gradient(135deg, #0066ff 0%, #00ccff 100%)';
                currentAudio = null;
                return;
            }

            // Create audio player element
            const audioPlayer = document.createElement('audio');
            audioPlayer.controls = true;
            audioPlayer.className = 'podcast-audio-player';
            audioPlayer.preload = 'metadata';
            audioPlayer.src = audioUrl;
            audioPlayer.style.width = '100%';
            audioPlayer.style.marginTop = '15px';
            audioPlayer.style.borderRadius = '8px';
            audioPlayer.style.outline = 'none';

            currentAudio = audioPlayer;
            episodeDiv.appendChild(audioPlayer);

            // Don't auto-play - let user click the audio player controls
            // This prevents mobile browser blocking
            playBtn.textContent = 'üéµ Playing';
            playBtn.style.background = 'linear-gradient(135deg, #00cc88 0%, #00ff99 100%)';
            playBtn.disabled = true;

            audioPlayer.onended = () => {
                playBtn.textContent = '‚ñ∂Ô∏è Play';
                playBtn.style.background = 'linear-gradient(135deg, #0066ff 0%, #00ccff 100%)';
                playBtn.disabled = false;
                currentAudio = null;
            };

            audioPlayer.onpause = () => {
                if (!audioPlayer.ended) {
                    playBtn.textContent = '‚ñ∂Ô∏è Resume';
                    playBtn.style.background = 'linear-gradient(135deg, #0066ff 0%, #00ccff 100%)';
                    playBtn.disabled = false;
                }
            };

            audioPlayer.onplay = () => {
                playBtn.textContent = 'üéµ Playing';
                playBtn.style.background = 'linear-gradient(135deg, #00cc88 0%, #00ff99 100%)';
                playBtn.disabled = true;
            };

            audioPlayer.onerror = (e) => {
                playBtn.textContent = '‚ùå Error';
                playBtn.style.background = 'linear-gradient(135deg, #666 0%, #999 100%)';
                playBtn.disabled = false;
                console.error('Audio loading error:', e);
                console.error('Audio URL:', audioUrl);
            };

            // Button doesn't control playback - just shows status
            // User clicks the audio player controls directly
            playBtn.onclick = null;
        }

        // Switch between Seasons and Tournaments tabs
        function switchTab(tab) {
            currentTab = tab;

            // Update tab button styles
            const seasonsBtn = document.getElementById('seasonsTab');
            const tournamentsBtn = document.getElementById('tournamentsTab');

            if (tab === 'seasons') {
                seasonsBtn.style.background = 'linear-gradient(135deg, #64ffda 0%, #00d9ff 100%)';
                seasonsBtn.style.color = '#0a192f';
                tournamentsBtn.style.background = 'rgba(100, 255, 218, 0.1)';
                tournamentsBtn.style.color = '#64ffda';
                document.getElementById('eventLabel').textContent = 'Season:';
                document.getElementById('leaderboardTitle').textContent = 'üèÜ Season Leaderboard';
                document.getElementById('coursesTableTitle').textContent = 'üèûÔ∏è Average Score by Course Tiers';
            } else {
                tournamentsBtn.style.background = 'linear-gradient(135deg, #64ffda 0%, #00d9ff 100%)';
                tournamentsBtn.style.color = '#0a192f';
                seasonsBtn.style.background = 'rgba(100, 255, 218, 0.1)';
                seasonsBtn.style.color = '#64ffda';
                document.getElementById('eventLabel').textContent = 'Tournament:';
                document.getElementById('leaderboardTitle').textContent = 'üèÜ Tournament Leaderboard';
                document.getElementById('coursesTableTitle').textContent = 'üèÅ Scores by Rounds';
            }

            // Load events for the selected tab
            loadEvents();
        }

        // Get selected event ID from dropdown
        function getSelectedEventId() {
            const select = document.getElementById('eventSelect');
            return select.value ? parseInt(select.value) : null;
        }

        // Load available events and populate dropdown based on current tab
        async function loadEvents() {
            const { data, error } = await supabase
                .from('events')
                .select('*')
                .eq('type', currentTab === 'seasons' ? 'season' : 'tournament')
                .eq('is_active', true)
                .order('year', { ascending: false });

            if (error) {
                console.error('Error loading events:', error);
                return;
            }

            availableEvents = data;

            // Populate dropdown
            const select = document.getElementById('eventSelect');
            select.innerHTML = '';

            if (availableEvents.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = currentTab === 'seasons' ? 'No seasons available' : 'No tournaments available';
                select.appendChild(option);

                // Clear all displays when no events available
                document.getElementById('leaderboard').innerHTML = '<p style="text-align: center; padding: 20px;">No ' + (currentTab === 'seasons' ? 'seasons' : 'tournaments') + ' available</p>';
                document.getElementById('birdieLeaders').innerHTML = '<p style="text-align: center; padding: 20px;">No data available</p>';
                document.getElementById('coursesTable').innerHTML = '<p style="text-align: center; padding: 20px;">No data available</p>';
                if (monthlyTrendChart) monthlyTrendChart.destroy();
                return;
            }

            availableEvents.forEach(event => {
                const option = document.createElement('option');
                option.value = event.id;
                option.textContent = event.name;
                select.appendChild(option);
            });

            // Select most recent event by default
            if (availableEvents.length > 0) {
                select.value = availableEvents[0].id;
            }

            // Load data for selected event
            loadAllData();
        }

        async function loadAllData() {
            await Promise.all([
                loadLeaderboard(),
                loadBirdieLeaders(),
                loadCoursesTable(),
                loadMonthlyTrend()
            ]);
        }

        async function loadLeaderboard() {
            const selectedEventId = getSelectedEventId();
            if (!selectedEventId) return;

            // Get rounds for selected event
            const { data: rounds, error: roundsError} = await supabase
                .from('rounds')
                .select('id')
                .eq('event_id', selectedEventId);

            if (roundsError) {
                document.getElementById('leaderboard').innerHTML = 'Error loading data';
                console.error('Rounds error:', roundsError);
                return;
            }

            const roundIds = rounds.map(r => r.id);
            if (roundIds.length === 0) {
                document.getElementById('leaderboard').innerHTML = '<p style="text-align: center; padding: 20px;">No data for this season</p>';
                return;
            }

            // Get player_rounds for these rounds
            const { data, error } = await supabase
                .from('player_rounds')
                .select('player_name, final_total, rank, round_id')
                .in('round_id', roundIds);

            if (error) {
                document.getElementById('leaderboard').innerHTML = 'Error loading data';
                console.error('Leaderboard error:', error);
                return;
            }

            // Filter for registered players only and collect all their rounds
            const playerRounds = {};
            data.forEach(round => {
                // Only count registered players (case-insensitive)
                if (!isRegisteredPlayer(round.player_name)) return;

                const canonicalName = getCanonicalPlayerName(round.player_name);
                if (!playerRounds[canonicalName]) {
                    playerRounds[canonicalName] = [];
                }
                playerRounds[canonicalName].push({
                    points: round.final_total || 0,
                    rank: round.rank
                });
            });

            // Calculate stats using only TOP 10 scores
            const playerStats = {};
            Object.entries(playerRounds).forEach(([name, rounds]) => {
                // Sort rounds by points (descending) and take top 10
                const sortedRounds = rounds.sort((a, b) => b.points - a.points);
                const top10Rounds = sortedRounds.slice(0, 10);

                playerStats[name] = {
                    points: top10Rounds.reduce((sum, r) => sum + r.points, 0),
                    rounds: rounds.length, // Total rounds played
                    countedRounds: top10Rounds.length, // Rounds counted (max 10)
                    wins: rounds.filter(r => r.rank === 1).length,
                    top3: rounds.filter(r => r.rank <= 3).length
                };
            });

            // SORT BY POINTS (descending)
            const leaderboard = Object.entries(playerStats)
                .map(([name, stats]) => ({ name, ...stats }))
                .sort((a, b) => b.points - a.points);

            let html = `<table><thead><tr><th>Rank</th><th>Player</th><th>Played</th><th>Points</th><th>Wins</th><th>Top 3</th></tr></thead><tbody>`;

            leaderboard.forEach((player, index) => {
                const rankClass = index === 0 ? 'rank-1' : index === 1 ? 'rank-2' : index === 2 ? 'rank-3' : 'rank-other';
                html += `<tr>
                    <td><span class="rank-badge ${rankClass}">${index + 1}</span></td>
                    <td><strong>${getDisplayName(player.name)}</strong></td>
                    <td>${player.rounds}</td>
                    <td><strong>${player.points.toFixed(1)}</strong></td>
                    <td>${player.wins}</td>
                    <td>${player.top3}</td>
                </tr>`;
            });
            html += '</tbody></table>';
            document.getElementById('leaderboard').innerHTML = html;
        }

        async function loadBirdieLeaders() {
            const selectedEventId = getSelectedEventId();
            if (!selectedEventId) return;

            // Get rounds for selected event
            const { data: rounds, error: roundsError } = await supabase
                .from('rounds')
                .select('id')
                .eq('event_id', selectedEventId);

            if (roundsError) {
                document.getElementById('birdieLeaders').innerHTML = 'Error loading data';
                return;
            }

            const roundIds = rounds.map(r => r.id);
            if (roundIds.length === 0) {
                document.getElementById('birdieLeaders').innerHTML = '<p style="text-align: center; padding: 20px;">No data for this season</p>';
                return;
            }

            const { data, error } = await supabase
                .from('player_rounds')
                .select('player_name, aces, eagles, birdies')
                .in('round_id', roundIds);

            if (error) {
                document.getElementById('birdieLeaders').innerHTML = 'Error loading data';
                return;
            }

            const playerStats = {};
            data.forEach(round => {
                // Only count registered players (case-insensitive)
                if (!isRegisteredPlayer(round.player_name)) return;

                const canonicalName = getCanonicalPlayerName(round.player_name);
                if (!playerStats[canonicalName]) {
                    playerStats[canonicalName] = { aces: 0, eagles: 0, birdies: 0 };
                }
                playerStats[canonicalName].aces += round.aces || 0;
                playerStats[canonicalName].eagles += round.eagles || 0;
                playerStats[canonicalName].birdies += round.birdies || 0;
            });

            // SORT BY TOTAL (descending)
            const sorted = Object.entries(playerStats)
                .map(([name, stats]) => ({ name, ...stats, total: stats.aces + stats.eagles + stats.birdies }))
                .sort((a, b) => b.total - a.total);

            const maxTotal = Math.max(...sorted.map(p => p.total), 1);

            let html = '<div style="padding: 10px;">';
            sorted.forEach(player => {
                const containerWidth = (player.total / maxTotal) * 100;
                html += `<div class="bar-container"><div class="player-name">${getDisplayName(player.name)}</div><div style="display: flex; align-items: center; flex: 1;"><div class="bars" style="width: ${containerWidth}%; max-width: 100%; display: flex; gap: 0;">`;
                if (player.aces > 0) html += `<div class="bar bar-ace" style="width: ${(player.aces / player.total) * 100}%; min-width: 30px;">${player.aces}</div>`;
                if (player.eagles > 0) html += `<div class="bar bar-eagle" style="width: ${(player.eagles / player.total) * 100}%; min-width: 30px;">${player.eagles}</div>`;
                if (player.birdies > 0) html += `<div class="bar bar-birdie" style="width: ${(player.birdies / player.total) * 100}%; min-width: 30px;">${player.birdies}</div>`;
                html += `</div><span style="margin-left: 10px; color: #64ffda; font-size: 0.9em; white-space: nowrap;">${player.total}</span></div></div>`;
            });
            html += '</div>';
            document.getElementById('birdieLeaders').innerHTML = html;
        }

        async function loadCoursesTable() {
            const selectedEventId = getSelectedEventId();
            if (!selectedEventId) return;

            const { data: rounds } = await supabase
                .from('rounds')
                .select('id, course_name, course_multiplier, date')
                .eq('event_id', selectedEventId)
                .order('date', { ascending: true });

            if (!rounds || rounds.length === 0) {
                document.getElementById('coursesTable').innerHTML = '<p style="text-align: center; padding: 20px;">No data available</p>';
                return;
            }

            const roundIds = rounds.map(r => r.id);
            const { data: playerRounds } = await supabase
                .from('player_rounds')
                .select('round_id, player_name, final_total')
                .in('round_id', roundIds);

            if (!playerRounds) return;

            // TOURNAMENT MODE: Show round-by-round scores
            if (currentTab === 'tournaments') {
                const playerStats = {};
                const playerTotalPoints = {};

                playerRounds.forEach(pr => {
                    // Only count registered players (case-insensitive)
                    if (!isRegisteredPlayer(pr.player_name)) return;

                    const canonicalName = getCanonicalPlayerName(pr.player_name);
                    if (!playerStats[canonicalName]) {
                        playerStats[canonicalName] = {};
                        playerTotalPoints[canonicalName] = 0;
                    }

                    playerStats[canonicalName][pr.round_id] = pr.final_total || 0;
                    playerTotalPoints[canonicalName] += pr.final_total || 0;
                });

                // Create table header with round numbers
                let html = `<table style="table-layout: fixed; width: 100%;"><thead><tr><th style="width: 20%;">Player</th>`;
                rounds.forEach((round, index) => {
                    html += `<th>Round ${index + 1}</th>`;
                });
                html += `</tr></thead><tbody>`;

                // Sort by total points descending
                const sortedPlayers = Object.keys(playerStats)
                    .sort((a, b) => playerTotalPoints[b] - playerTotalPoints[a]);

                sortedPlayers.forEach(player => {
                    html += `<tr><td><strong>${getDisplayName(player)}</strong></td>`;
                    rounds.forEach(round => {
                        const score = playerStats[player][round.id];
                        html += score ? `<td>${score.toFixed(1)}</td>` : `<td style="color: #555;">-</td>`;
                    });
                    html += `</tr>`;
                });

                html += '</tbody></table>';
                document.getElementById('coursesTable').innerHTML = html;

            } else {
                // SEASON MODE: Show tier-based averages
                const roundMap = {};
                rounds.forEach(r => { roundMap[r.id] = r.course_multiplier || 1.0; });

                const playerStats = {};
                const playerTotalPoints = {};

                playerRounds.forEach(pr => {
                    // Only count registered players (case-insensitive)
                    if (!isRegisteredPlayer(pr.player_name)) return;

                    const canonicalName = getCanonicalPlayerName(pr.player_name);
                    const tier = roundMap[pr.round_id];
                    if (!tier) return;
                    if (!playerStats[canonicalName]) {
                        playerStats[canonicalName] = {};
                        playerTotalPoints[canonicalName] = 0;
                    }
                    if (!playerStats[canonicalName][tier]) playerStats[canonicalName][tier] = { total: 0, count: 0 };
                    playerStats[canonicalName][tier].total += pr.final_total || 0;
                    playerStats[canonicalName][tier].count += 1;
                    playerTotalPoints[canonicalName] += pr.final_total || 0;
                });

                // Define all tiers
                const allTiers = [
                    { multiplier: 2.5, label: 'Elite' },
                    { multiplier: 2.0, label: 'Hard' },
                    { multiplier: 1.5, label: 'Medium' },
                    { multiplier: 1.0, label: 'Easy' }
                ];

                let html = `<table style="table-layout: fixed; width: 100%;"><thead><tr><th style="width: 25%;">Player</th>`;
                allTiers.forEach(tier => { html += `<th style="width: 18.75%;">${tier.label}</th>`; });
                html += `</tr></thead><tbody>`;

                // SORT BY TOTAL SEASON POINTS (descending)
                const sortedPlayers = Object.keys(playerStats)
                    .sort((a, b) => playerTotalPoints[b] - playerTotalPoints[a]);

                sortedPlayers.forEach(player => {
                    html += `<tr><td><strong>${getDisplayName(player)}</strong></td>`;
                    allTiers.forEach(tier => {
                        const stats = playerStats[player][tier.multiplier];
                        html += stats ? `<td>${(stats.total / stats.count).toFixed(1)}</td>` : `<td style="color: #555;">-</td>`;
                    });
                    html += `</tr>`;
                });
                html += '</tbody></table>';
                document.getElementById('coursesTable').innerHTML = html;
            }
        }

        async function loadMonthlyTrend() {
            const selectedEventId = getSelectedEventId();
            if (!selectedEventId) return;

            const { data: rounds } = await supabase
                .from('rounds')
                .select('id, date')
                .eq('event_id', selectedEventId)
                .order('date', { ascending: true });

            if (!rounds || rounds.length === 0) return;

            const roundIds = rounds.map(r => r.id);
            const { data: playerRounds } = await supabase
                .from('player_rounds')
                .select('round_id, player_name, final_total')
                .in('round_id', roundIds);

            if (!playerRounds) return;

            const roundDateMap = {};
            rounds.forEach(r => { roundDateMap[r.id] = r.date; });

            const colors = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40', '#FF6384', '#4DC9F6', '#8BC34A', '#7C4DFF'];

            // Check if we're viewing tournaments or seasons
            if (currentTab === 'tournaments') {
                // For tournaments: show round-by-round cumulative points
                document.getElementById('trendChartTitle').textContent = 'üìà Points Trend';

                // Create player data structure: player -> array of points per round
                const playerRoundData = {};
                rounds.forEach((round, roundIndex) => {
                    playerRounds.forEach(pr => {
                        if (!REGISTERED_PLAYERS.includes(pr.player_name)) return;
                        if (pr.round_id !== round.id) return;

                        if (!playerRoundData[pr.player_name]) {
                            playerRoundData[pr.player_name] = new Array(rounds.length).fill(0);
                        }
                        playerRoundData[pr.player_name][roundIndex] = pr.final_total || 0;
                    });
                });

                // Create round labels (Round 1, Round 2, etc.)
                const roundLabels = rounds.map((_, index) => `Round ${index + 1}`);

                const datasets = Object.entries(playerRoundData).map(([player, roundPoints], index) => {
                    // Calculate cumulative totals across rounds
                    let cumulative = 0;
                    const cumulativeData = roundPoints.map(points => {
                        cumulative += points;
                        return cumulative;
                    });

                    return {
                        label: getDisplayName(player),
                        data: cumulativeData,
                        borderColor: colors[index % colors.length],
                        backgroundColor: colors[index % colors.length] + '40',
                        tension: 0.3,
                        fill: false,
                        borderWidth: 2
                    };
                });

                const ctx = document.getElementById('monthlyTrendChart');
                if (monthlyTrendChart) monthlyTrendChart.destroy();
                monthlyTrendChart = new Chart(ctx, {
                    type: 'line',
                    data: { labels: roundLabels, datasets: datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { position: 'top', labels: { color: '#64ffda', font: { size: 12 } } } },
                        scales: {
                            y: { beginAtZero: true, title: { display: true, text: 'Points', color: '#64ffda' }, ticks: { color: '#e6f1ff' }, grid: { color: 'rgba(100, 255, 218, 0.1)' } },
                            x: { title: { display: true, text: 'Round', color: '#64ffda' }, ticks: { color: '#e6f1ff' }, grid: { color: 'rgba(100, 255, 218, 0.1)' } }
                        }
                    }
                });
            } else {
                // For seasons: show monthly cumulative points (existing logic)
                document.getElementById('trendChartTitle').textContent = 'üìà Monthly Points Trend';

                const playerMonthlyData = {};
                playerRounds.forEach(pr => {
                    // Only count registered players
                    if (!REGISTERED_PLAYERS.includes(pr.player_name)) return;

                    const date = roundDateMap[pr.round_id];
                    if (!date) return;
                    const month = date.substring(0, 7);
                    if (!playerMonthlyData[pr.player_name]) playerMonthlyData[pr.player_name] = {};
                    if (!playerMonthlyData[pr.player_name][month]) playerMonthlyData[pr.player_name][month] = 0;
                    playerMonthlyData[pr.player_name][month] += pr.final_total || 0;
                });

                const allMonths = [...new Set(Object.values(roundDateMap).map(d => d.substring(0, 7)))].sort();
                const datasets = Object.entries(playerMonthlyData).map(([player, months], index) => {
                    // Calculate cumulative totals
                    let cumulative = 0;
                    const cumulativeData = allMonths.map(month => {
                        cumulative += months[month] || 0;
                        return cumulative;
                    });

                    return {
                        label: getDisplayName(player),
                        data: cumulativeData,
                        borderColor: colors[index % colors.length],
                        backgroundColor: colors[index % colors.length] + '40',
                        tension: 0.3,
                        fill: false,
                        borderWidth: 2
                    };
                });

                const ctx = document.getElementById('monthlyTrendChart');
                if (monthlyTrendChart) monthlyTrendChart.destroy();
                monthlyTrendChart = new Chart(ctx, {
                    type: 'line',
                    data: { labels: allMonths, datasets: datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { position: 'top', labels: { color: '#64ffda', font: { size: 12 } } } },
                        scales: {
                            y: { beginAtZero: true, title: { display: true, text: 'Points', color: '#64ffda' }, ticks: { color: '#e6f1ff' }, grid: { color: 'rgba(100, 255, 218, 0.1)' } },
                            x: { title: { display: true, text: 'Month', color: '#64ffda' }, ticks: { color: '#e6f1ff' }, grid: { color: 'rgba(100, 255, 218, 0.1)' } }
                        }
                    }
                });
            }
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter') sendMessage();
        }

        async function sendMessage() {
            const input = document.getElementById('chatInput');
            const question = input.value.trim();
            if (!question) return;

            const chatBox = document.getElementById('chatBox');
            const chatSection = document.getElementById('chatSection');
            chatBox.classList.add('visible');
            chatSection.classList.add('expanded');

            addMessage(question, 'user');
            input.value = '';

            const sendBtn = document.getElementById('sendBtn');
            sendBtn.disabled = true;
            sendBtn.textContent = 'Thinking...';

            try {
                const response = await fetch(N8N_CHATBOT_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ question })
                });
                const data = await response.json();
                addMessage(data.answer || 'Sorry, I could not process that question.', 'bot');
            } catch (error) {
                console.error('Chat error:', error);
                addMessage('Error: Could not connect to chatbot.', 'bot');
            }

            sendBtn.disabled = false;
            sendBtn.textContent = 'Send';
        }

        function addMessage(text, type) {
            const chatBox = document.getElementById('chatBox');
            const message = document.createElement('div');
            message.className = `message ${type}-message`;
            message.style.whiteSpace = 'pre-wrap';
            message.textContent = text;
            chatBox.appendChild(message);
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        // Pun system - 200 hilarious disc golf one-liners
        const discGolfPuns = [
            // Trees & Obstacles (40 puns)
            { icon: 'üå≤', text: 'Warning: Trees are 90% air, but your disc will find the other 10% every time.' },
            { icon: 'üå≥', text: 'Tree Fact: They\'re called "tree magnets" for a reason. Your disc agrees.' },
            { icon: 'üéØ', text: 'Pro Tip: The gap between trees is called "optimism." Use sparingly.' },
            { icon: '‚ö†Ô∏è', text: 'Hazard Alert: That tree wasn\'t there on your practice throw. We checked.' },
            { icon: 'üå≤', text: 'Breaking: Local tree reports 47th disc this week. "Business is good," says tree.' },
            { icon: 'üå≥', text: 'Fun Fact: Trees don\'t move. Your disc does. Physics is against you.' },
            { icon: '‚ö†Ô∏è', text: 'Important: If you can see the basket through the trees, that\'s called "false hope."' },
            { icon: 'üå≤', text: 'Update: Tree population remains undefeated against disc golfers since 1970.' },
            { icon: 'üé™', text: 'Entertainment: Watch grown adults argue with vegetation. Tonight at 7!' },
            { icon: 'üå≥', text: 'Reminder: Throwing harder at the tree won\'t make it move. We\'ve tested this.' },
            { icon: '‚ö†Ô∏è', text: 'PSA: Your disc is now an ornament. The tree accepts your donation.' },
            { icon: 'üå≤', text: 'Tree Review: "Five stars! Caught every disc thrown near me." - Oak on Hole 7' },
            { icon: 'üå≥', text: 'Spoiler: That gap looked bigger from the tee pad. It wasn\'t.' },
            { icon: 'üéØ', text: 'Accuracy Check: You hit exactly what you were looking at. Unfortunately, that was a tree.' },
            { icon: '‚ö†Ô∏è', text: 'Notice: Trees grow in the exact spot you need them not to be. Coincidence? We think not.' },
            { icon: 'üå≤', text: 'Fact: The tree is not sorry. The tree never was. The tree never will be.' },
            { icon: 'üå≥', text: 'Update: Your disc ricocheted off 3 trees and went backwards. New record!' },
            { icon: '‚ö†Ô∏è', text: 'Alert: That wasn\'t a "skip shot." That was tree violence.' },
            { icon: 'üå≤', text: 'Observation: You threw around 47 trees successfully. Congratulations on finding #48.' },
            { icon: 'üå≥', text: 'Report: Tree says it was "just standing there." Your disc had no comment.' },
            { icon: '‚ö†Ô∏è', text: 'Warning: Attempting to throw through solid objects may result in disappointment.' },
            { icon: 'üå≤', text: 'Bulletin: Trees are stationary. This has been confirmed by science.' },
            { icon: 'üå≥', text: 'News Flash: Man yells at tree. Tree unbothered. Disc still stuck.' },
            { icon: 'üéØ', text: 'Discovery: Trees are surprisingly good goalies. Who knew?' },
            { icon: '‚ö†Ô∏è', text: 'Attention: Your disc found the only tree in a 50-foot radius. Impressive.' },
            { icon: 'üå≤', text: 'Memo: Trees don\'t have feelings, but they do have your disc.' },
            { icon: 'üå≥', text: 'Update: Local squirrel now has nicer discs than you. Thanks, tree.' },
            { icon: '‚ö†Ô∏è', text: 'Alert: The tree hit percentage on this hole is 87%. You\'re not special.' },
            { icon: 'üå≤', text: 'Reminder: Trees are disc golf\'s most consistent defensive players.' },
            { icon: 'üå≥', text: 'Fact: Your disc curved. The tree didn\'t. Guess who won?' },
            { icon: 'üé™', text: 'Performance Art: Watching someone shake a tree for 10 minutes. Beautiful.' },
            { icon: '‚ö†Ô∏è', text: 'Warning: "Thread the needle" is a suggestion, not a guarantee.' },
            { icon: 'üå≤', text: 'Report: Tree population vs. Disc Golf Population. Trees winning 1,000,000 to 0.' },
            { icon: 'üå≥', text: 'Notice: Your disc went left. The basket is right. The tree is laughing.' },
            { icon: '‚ö†Ô∏è', text: 'Safety Tip: Trees are harder than discs. Don\'t challenge them.' },
            { icon: 'üå≤', text: 'Breaking: Tree refuses to apologize for being exactly where it\'s always been.' },
            { icon: 'üå≥', text: 'Fun Fact: Every tree on the course is personally offended by your throw.' },
            { icon: 'üéØ', text: 'Accuracy Update: You hit your target! Oh wait, that was the wrong target.' },
            { icon: '‚ö†Ô∏è', text: 'Hazard: The trees are plotting against you. All of them.' },
            { icon: 'üå≤', text: 'Tree Status: Still there. Still catching discs. Still unimpressed.' },

            // Wind & Weather (30 puns)
            { icon: 'üå™Ô∏è', text: 'Weather Report: Wind speed is "yes." Plan accordingly.' },
            { icon: 'üí®', text: 'Wind Advisory: Your disc will go everywhere except where you threw it.' },
            { icon: 'üåßÔ∏è', text: 'Forecast: 100% chance of excuses. Expect heavy complaints.' },
            { icon: '‚òÄÔ∏è', text: 'Hot Take: The sun is in your eyes. And your opponent\'s. Physics doesn\'t care.' },
            { icon: 'üå™Ô∏è', text: 'Update: Wind changed direction mid-flight just to spite you specifically.' },
            { icon: 'üí®', text: 'Breaking: Local player blames wind for putt from 2 feet. Wind unavailable for comment.' },
            { icon: 'üåßÔ∏è', text: 'Rain Check: Wet disc + wet hands = adventure. Good luck!' },
            { icon: '‚ö†Ô∏è', text: 'Alert: Headwind on drives, tailwind on putts. Murphy\'s Law confirmed.' },
            { icon: 'üå™Ô∏è', text: 'Notice: Wind is not your friend. Wind has never been your friend.' },
            { icon: 'üí®', text: 'Fact: Wind only exists when you\'re winning. Coincidence? Absolutely not.' },
            { icon: 'üåßÔ∏è', text: 'Update: Rain makes discs slippery. Who could have predicted this?' },
            { icon: '‚òÄÔ∏è', text: 'Sun Advisory: You can\'t see, you\'re sweating, but hey - nice day!' },
            { icon: 'üå™Ô∏è', text: 'Wind Status: Chaos mode activated. All bets are off.' },
            { icon: 'üí®', text: 'Breeze Report: That 2 mph wind totally affected your 40-foot putt. Sure.' },
            { icon: 'üåßÔ∏è', text: 'Weather Fact: Rain makes bad throws 47% more dramatic.' },
            { icon: '‚ö†Ô∏è', text: 'Warning: Mud and dignity don\'t mix. Choose wisely.' },
            { icon: 'üå™Ô∏è', text: 'Gust Update: Wind gusted at the exact moment of release. Every. Single. Time.' },
            { icon: 'üí®', text: 'Forecast: Wind will be perfect... for your competitor.' },
            { icon: 'üåßÔ∏è', text: 'Rain Fact: Soggy discs fly like soggy pancakes. Science!' },
            { icon: '‚òÄÔ∏è', text: 'Heat Index: Too hot to think, perfect for bad decisions!' },
            { icon: 'üå™Ô∏è', text: 'Alert: Wind is now considered a competitive player. Currently ranked #1.' },
            { icon: 'üí®', text: 'Update: That wasn\'t wind. That was your disc\'s poor life choices.' },
            { icon: 'üåßÔ∏è', text: 'Splash Zone: Water hazards are now "disc collectors." Resistance is futile.' },
            { icon: '‚ö†Ô∏è', text: 'Advisory: Lightning means stop playing. But you won\'t. We know you.' },
            { icon: 'üå™Ô∏è', text: 'Wind Pattern: Chaotic evil. No further details available.' },
            { icon: 'üí®', text: 'Fun Fact: Wind always knows which way you DON\'T want it to blow.' },
            { icon: 'üåßÔ∏è', text: 'Precipitation Update: Everything is wet. You are wet. Accept it.' },
            { icon: '‚òÄÔ∏è', text: 'Sunshine Report: Great visibility to watch your disc miss spectacularly!' },
            { icon: 'üå™Ô∏è', text: 'Breaking: Meteorologist confirms wind is "just messing with you now."' },
            { icon: 'üí®', text: 'Breeze Status: Strong enough to blame, weak enough to be questioned.' },

            // Putting (40 puns)
            { icon: 'üéØ', text: 'Putt Update: From this distance, you\'re more likely to hit Mars than chains.' },
            { icon: 'üîî', text: 'Chain Fact: They make beautiful sounds when OTHER people putt.' },
            { icon: '‚ö†Ô∏è', text: 'Alert: That 10-footer is actually a 30-footer. Perspective is everything.' },
            { icon: 'üéØ', text: 'Putting Tip: Missing left and right equally means you\'re "consistent."' },
            { icon: 'üîî', text: 'Reminder: Chains are designed to catch discs. Yours disagree.' },
            { icon: '‚ö†Ô∏è', text: 'Notice: Three-putting from 15 feet is called "getting your steps in."' },
            { icon: 'üéØ', text: 'Fun Fact: 90% of putts don\'t go in if you leave them short. The other 10% also don\'t.' },
            { icon: 'üîî', text: 'Chain Report: Working perfectly. Just not with your disc.' },
            { icon: '‚ö†Ô∏è', text: 'PSA: Chains are not "too bouncy." You just throw too hard.' },
            { icon: 'üéØ', text: 'Putting Stats: You made that exact putt in practice. Practice doesn\'t count.' },
            { icon: 'üîî', text: 'Sound Alert: That "thud" sound means you hit the basket wrong. Congrats!' },
            { icon: '‚ö†Ô∏è', text: 'Warning: Staring at the basket won\'t make it bigger. We\'ve tried.' },
            { icon: 'üéØ', text: 'Pro Tip: If you can touch the basket, you can still miss the putt.' },
            { icon: 'üîî', text: 'Chain Music: Beautiful melody available. Your disc sold separately.' },
            { icon: '‚ö†Ô∏è', text: 'Update: You\'ve now putted over/under/around the basket. Achievement unlocked!' },
            { icon: 'üéØ', text: 'Putting Fact: Confidence and accuracy are inversely proportional.' },
            { icon: 'üîî', text: 'Ding Ding! Oh wait, that was someone else\'s disc. Carry on.' },
            { icon: '‚ö†Ô∏è', text: 'Notice: That "circle of confidence" is more like an "oval of hope."' },
            { icon: 'üéØ', text: 'Reality Check: You sank this putt in your head. Your disc didn\'t get the memo.' },
            { icon: 'üîî', text: 'Chain Study: Scientists confirm they work. Your results may vary.' },
            { icon: '‚ö†Ô∏è', text: 'Alert: "Kick-in" putts are 50% skill, 50% begging.' },
            { icon: 'üéØ', text: 'Putt Analysis: Too high, too low, too left, too right. Perfect!' },
            { icon: 'üîî', text: 'Breaking: Man argues with chains about "should have stayed in." Chains win.' },
            { icon: '‚ö†Ô∏è', text: 'Reminder: A gimme is only a gimme if everyone agrees. They don\'t.' },
            { icon: 'üéØ', text: 'Putting Truth: You can make a 50-footer in practice but not a 10-footer in competition.' },
            { icon: 'üîî', text: 'Chain Reaction: Your disc had one. It was leaving the basket area.' },
            { icon: '‚ö†Ô∏è', text: 'Warning: Putting your foot closer won\'t help. The basket knows what you did.' },
            { icon: 'üéØ', text: 'Update: Your putt hit every part of the basket except the inside.' },
            { icon: 'üîî', text: 'Fun Fact: Chains catch 99% of putts. Just not yours right now.' },
            { icon: '‚ö†Ô∏è', text: 'PSA: "Good putt" is what people say when you miss. Translation: nice try.' },
            { icon: 'üéØ', text: 'Putting Wisdom: If you aim at nothing, you\'ll hit it every time.' },
            { icon: 'üîî', text: 'Chain Status: Ready and willing. Your disc is not.' },
            { icon: '‚ö†Ô∏è', text: 'Notice: That wasn\'t a spit-out. That was a rejection.' },
            { icon: 'üéØ', text: 'Truth Bomb: You make that putt alone. You miss it with witnesses.' },
            { icon: 'üîî', text: 'Sound Effect: *CLANG* Translation: So close yet so far.' },
            { icon: '‚ö†Ô∏è', text: 'Attention: Jump putts are for people who want to miss from farther away.' },
            { icon: 'üéØ', text: 'Putt Report: Height - good. Direction - questionable. Result - try again.' },
            { icon: 'üîî', text: 'Chain Fact: They\'re right there. Like, RIGHT there. How did you miss?' },
            { icon: '‚ö†Ô∏è', text: 'Update: You\'ve invented a new putting style called "optimistic chaos."' },
            { icon: 'üéØ', text: 'Final Word: The basket is large. The chains are many. Your disc is lost.' },

            // Discs & Equipment (30 puns)
            { icon: 'üíø', text: 'Disc Report: You have 47 discs but throw the same 3 every round.' },
            { icon: 'üé®', text: 'Color Fact: Bright pink discs are easier to find. You still bought blue.' },
            { icon: '‚ö†Ô∏è', text: 'Warning: That $30 disc will not make you throw better. But you\'ll buy it anyway.' },
            { icon: 'üíø', text: 'Update: Your bag weighs 40 pounds. You only use 4 discs. Math doesn\'t check out.' },
            { icon: 'üé®', text: 'Notice: Limited edition plastic doesn\'t fly differently. Your wallet disagrees.' },
            { icon: '‚ö†Ô∏è', text: 'Breaking: Local player blames disc for bad throw. Disc has receipts.' },
            { icon: 'üíø', text: 'Disc Math: More discs = more better. Science says no. You say yes.' },
            { icon: 'üé®', text: 'Fun Fact: That disc is "understable." So is your decision to buy it.' },
            { icon: '‚ö†Ô∏è', text: 'Alert: You need a new disc like you need a hole in your... wallet.' },
            { icon: 'üíø', text: 'Reminder: Every disc is "the one" until the next one comes out.' },
            { icon: 'üé®', text: 'Color Theory: White discs are for people who enjoy long searches.' },
            { icon: '‚ö†Ô∏è', text: 'PSA: "Seasoning" your disc is just an excuse for scratches and dents.' },
            { icon: 'üíø', text: 'Truth: You don\'t need another putter. You need to practice with the ones you have.' },
            { icon: 'üé®', text: 'Observation: Pink discs in pink bags. This is peak camouflage fail.' },
            { icon: '‚ö†Ô∏è', text: 'Update: Your "overstable" disc is now a "tree-stable" disc.' },
            { icon: 'üíø', text: 'Disc Status: Lost in the woods. Last known speed: too fast.' },
            { icon: 'üé®', text: 'Breaking: Man owns 15 putters. Still can\'t putt. Putter sales continue.' },
            { icon: '‚ö†Ô∏è', text: 'Warning: That disc is "out of production" because it was terrible.' },
            { icon: 'üíø', text: 'Bag Check: 20 discs, 1 towel, 3 snacks. Priorities are clear.' },
            { icon: 'üé®', text: 'Design Update: Cool stamp won\'t help you throw. Still looks rad though!' },
            { icon: '‚ö†Ô∏è', text: 'Notice: "Beginner-friendly" discs are for beginners. You are not fooling anyone.' },
            { icon: 'üíø', text: 'Disc Fact: The perfect disc exists. It\'s the one you lost last week.' },
            { icon: 'üé®', text: 'Color Advisory: "Glow" discs help you lose discs in the dark more efficiently!' },
            { icon: '‚ö†Ô∏è', text: 'Alert: Switching discs mid-round won\'t fix your form. But go ahead.' },
            { icon: 'üíø', text: 'Truth Bomb: Your backup disc flies exactly like your main disc. Badly.' },
            { icon: 'üé®', text: 'Update: Tie-dye discs don\'t make you throw better. They make you look cool missing.' },
            { icon: '‚ö†Ô∏è', text: 'PSA: "Breaking in" your disc means hitting trees. You\'re doing great!' },
            { icon: 'üíø', text: 'Disc Economics: Spent $300 on plastic. Score hasn\'t improved. System working as intended.' },
            { icon: 'üé®', text: 'Fun Fact: Clear discs are for people who enjoy losing things permanently.' },
            { icon: '‚ö†Ô∏è', text: 'Warning: That disc flies perfectly... for someone else.' },

            // Scores & Competition (30 puns)
            { icon: 'üèÜ', text: 'Leaderboard Update: You\'re not last! (Someone didn\'t finish)' },
            { icon: 'üìä', text: 'Score Check: That\'s not a score. That\'s a phone number.' },
            { icon: '‚ö†Ô∏è', text: 'Reality: Par is a suggestion. You\'ve decided to ignore it completely.' },
            { icon: 'üèÜ', text: 'Competition Status: You vs. You from last week. Last week\'s you is winning.' },
            { icon: 'üìä', text: 'Stat Update: 100% of your shots got you closer to finishing. Eventually.' },
            { icon: '‚ö†Ô∏è', text: 'Breaking: Local player invents new score called "I\'d rather not say."' },
            { icon: 'üèÜ', text: 'Tournament Alert: You finished! That\'s... that\'s actually great!' },
            { icon: 'üìä', text: 'Math Time: Par plus 8 is called "having fun." Right? Right??' },
            { icon: '‚ö†Ô∏è', text: 'Score Report: Higher numbers aren\'t better in disc golf. Reminder sent.' },
            { icon: 'üèÜ', text: 'Achievement: Completed round without losing disc. Victory!' },
            { icon: 'üìä', text: 'Stats Don\'t Lie: You played all 18 holes. Your score is evidence.' },
            { icon: '‚ö†Ô∏è', text: 'Notice: "Casual round" scores don\'t count. Translation: it went poorly.' },
            { icon: 'üèÜ', text: 'Update: You beat your personal worst! Oh wait...' },
            { icon: 'üìä', text: 'Scorecard Truth: Writing "4" when you got a 7 doesn\'t change reality.' },
            { icon: '‚ö†Ô∏è', text: 'Alert: That wasn\'t a "birdie try." That was attempting par.' },
            { icon: 'üèÜ', text: 'Victory Condition: You vs. the course. Course is undefeated.' },
            { icon: 'üìä', text: 'Fun Fact: Negative scores are good. You have positive scores. Many positive.' },
            { icon: '‚ö†Ô∏è', text: 'Reminder: The max score per hole is 10. You\'ve reached it. Several times.' },
            { icon: 'üèÜ', text: 'Podium Update: You\'re in 7th place! (Out of 7 players)' },
            { icon: 'üìä', text: 'Score Analysis: Consistent! Consistently over par, but still.' },
            { icon: '‚ö†Ô∏è', text: 'Breaking: Player declares "that hole doesn\'t count." Scorecard disagrees.' },
            { icon: 'üèÜ', text: 'Trophy Status: "Participation Award" is still an award. Congrats!' },
            { icon: 'üìä', text: 'Math Check: You shot your age! (If you\'re 73 years old)' },
            { icon: '‚ö†Ô∏è', text: 'PSA: Comparing your score to pros is "unhealthy." We don\'t recommend it.' },
            { icon: 'üèÜ', text: 'Update: You won something! (Most trees hit in a single round)' },
            { icon: 'üìä', text: 'Score Truth: It\'s not about the score, it\'s about... who are we kidding, it\'s the score.' },
            { icon: '‚ö†Ô∏è', text: 'Alert: Your handicap is called "existing." We\'re working on it.' },
            { icon: 'üèÜ', text: 'Victory Lap: You finished before dark. That\'s the real win!' },
            { icon: 'üìä', text: 'Statistic: You improved by 0.5 strokes this month. See you in 2028 for par!' },
            { icon: '‚ö†Ô∏è', text: 'Final Score: Let\'s just say you "completed the course" and leave it at that.' },

            // General Humor & Philosophy (30 puns)
            { icon: 'üé™', text: 'Philosophy: Disc golf - because golf is expensive and hiking is boring!' },
            { icon: 'üß†', text: 'Deep Thought: You came for exercise. You\'re getting a therapy session.' },
            { icon: '‚ö†Ô∏è', text: 'Life Lesson: The journey matters more than the destination. Especially when you\'re looking for your disc.' },
            { icon: 'üé™', text: 'Truth: Disc golf is 90% mental. The other 10% is also mental.' },
            { icon: 'üß†', text: 'Wisdom: Every throw is a learning experience. Today you learned a lot.' },
            { icon: '‚ö†Ô∏è', text: 'Reality Check: You\'re throwing plastic at metal chains. This is your hobby.' },
            { icon: 'üé™', text: 'Fun Fact: Disc golf keeps you humble. Extremely humble. Painfully humble.' },
            { icon: 'üß†', text: 'Observation: You started happy. Now you\'re arguing with a tree. Character development!' },
            { icon: '‚ö†Ô∏è', text: 'Update: Disc golf is "relaxing." Also: lies people tell themselves.' },
            { icon: 'üé™', text: 'Breaking: Adults pay money to throw plastic in the woods. Society is fine.' },
            { icon: 'üß†', text: 'Psychology: You keep playing because "next time will be better." Narrator: It wasn\'t.' },
            { icon: '‚ö†Ô∏è', text: 'Life Update: Your disc golf game reflects your life choices. Concerning.' },
            { icon: 'üé™', text: 'Entertainment: Watching someone\'s round fall apart on Hole 7. Classic cinema.' },
            { icon: 'üß†', text: 'Mindfulness: Be present. In this moment, you are over par. Very over par.' },
            { icon: '‚ö†Ô∏è', text: 'Notice: Disc golf is "just for fun." So is screaming into the void.' },
            { icon: 'üé™', text: 'Social Study: Disc golfers are the only people who celebrate hitting metal.' },
            { icon: 'üß†', text: 'Meditation: Breathe in. Breathe out. Miss putt. Breathe angrily.' },
            { icon: '‚ö†Ô∏è', text: 'Truth: You love disc golf. Disc golf tolerates you.' },
            { icon: 'üé™', text: 'Documentary: Man walks in circles for 2 hours. Calls it "sport." More at 11.' },
            { icon: 'üß†', text: 'Zen Moment: The disc is not your enemy. The disc is your teacher. A harsh teacher.' },
            { icon: '‚ö†Ô∏è', text: 'Update: You said "just one more round." That was 3 hours ago.' },
            { icon: 'üé™', text: 'Comedy Gold: Pretending that shank was intentional. Oscar-worthy performance!' },
            { icon: 'üß†', text: 'Enlightenment: The basket is always there. Your disc rarely is.' },
            { icon: '‚ö†Ô∏è', text: 'PSA: Disc golf addiction is real. Symptoms include: more discs, worse scores.' },
            { icon: 'üé™', text: 'Theatre: The dramatic sigh after a bad shot. Perfection. 10/10.' },
            { icon: 'üß†', text: 'Philosophy: If a disc falls in the woods and no one sees it, did you still lose?' },
            { icon: '‚ö†Ô∏è', text: 'Warning: Objects in scorecard are worse than they appear.' },
            { icon: 'üé™', text: 'Performance Art: The walk of shame after an air ball. Beautiful.' },
            { icon: 'üß†', text: 'Wisdom: Every pro was once a beginner. You are proving this. Extensively.' },
            { icon: 'üéØ', text: 'Final Truth: Disc golf is hard. But you keep coming back. That\'s the spirit!' }
        ];

        function getRandomPun() {
            return discGolfPuns[Math.floor(Math.random() * discGolfPuns.length)];
        }

        function displayPun() {
            const pun = getRandomPun();
            document.getElementById('punIcon').textContent = pun.icon;
            document.getElementById('punText').textContent = pun.text;
        }

        function refreshPun() {
            const banner = document.getElementById('punBanner');
            banner.style.animation = 'none';
            setTimeout(() => {
                banner.style.animation = 'slideDown 0.6s ease-out';
                displayPun();
            }, 10);
        }

        // Initialize: Load events first, then load data
        async function initialize() {
            displayPun(); // Show initial pun
            await loadEvents();
        }

        initialize();
        setInterval(loadAllData, 300000); // Auto-refresh every 5 minutes
        setInterval(refreshPun, 45000); // Auto-change pun every 45 seconds
    </script>
</body>
</html>
