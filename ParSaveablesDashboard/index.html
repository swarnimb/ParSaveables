<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ParSaveables</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Rajdhani', 'Orbitron', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1d35 25%, #2d1b3d 50%, #1a1d35 75%, #0a0e27 100%);
            background-attachment: fixed;
            min-height: 100vh;
            padding: 20px;
            color: #ffffff;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    rgba(255, 0, 100, 0.03) 2px,
                    rgba(255, 0, 100, 0.03) 4px
                );
            pointer-events: none;
            z-index: 1;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 2;
        }
        
        header {
            text-align: center;
            color: #ffffff;
            margin-bottom: 30px;
            position: relative;
            background: linear-gradient(135deg, rgba(255, 0, 100, 0.15) 0%, rgba(255, 102, 0, 0.15) 50%, rgba(255, 215, 0, 0.15) 100%);
            padding: 30px;
            border-radius: 20px;
            box-shadow:
                0 0 60px rgba(255, 0, 100, 0.3),
                0 0 30px rgba(255, 102, 0, 0.2),
                0 8px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            background-clip: padding-box;
            backdrop-filter: blur(20px);
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #ff0064, #ff6600, #ffd700, #ff6600, #ff0064);
            background-size: 400% 400%;
            border-radius: 20px;
            z-index: -1;
            animation: gradientShift 3s ease infinite;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        .logo-container {
            display: inline-block;
            position: relative;
            margin-bottom: 15px;
        }
        
        .logo {
            width: 80px;
            height: 80px;
            filter: drop-shadow(0 4px 8px rgba(100, 255, 218, 0.4));
        }
        
        header h1 {
            font-size: 3.5em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #cc5577 0%, #dd8822 25%, #eebb00 50%, #dd8822 75%, #cc5577 100%);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            -webkit-text-stroke: 1.5px rgba(255, 255, 255, 0.4);
            font-weight: 700;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            text-transform: uppercase;
            animation: shine 3s linear infinite;
            filter: drop-shadow(0 0 15px rgba(255, 238, 68, 0.6));
        }

        @keyframes shine {
            to { background-position: 200% center; }
        }
        
        
        .chat-section {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(250, 250, 252, 0.98) 100%);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.08), 0 2px 8px rgba(0, 0, 0, 0.04);
            margin-bottom: 25px;
            margin-left: auto;
            margin-right: auto;
            max-width: 800px;
            border: 1px solid rgba(255, 255, 255, 0.9);
            border-top: none;
            transition: all 0.3s ease;
            min-height: auto;
            display: flex;
            flex-direction: column;
        }

        .chat-section.expanded {
            padding: 20px;
            min-height: 450px;
        }

        .chat-box {
            height: 0;
            overflow: hidden;
            border: 1px solid rgba(100, 255, 218, 0.2);
            border-radius: 10px;
            padding: 0;
            margin-bottom: 0;
            background: rgba(10, 25, 47, 0.6);
            transition: all 0.3s ease;
        }

        .chat-box.visible {
            height: 350px;
            overflow-y: auto;
            padding: 10px;
            margin-bottom: 10px;
        }
        
        .message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            max-width: 80%;
            animation: fadeIn 0.3s;
            font-size: 0.9em;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .user-message {
            background: linear-gradient(135deg, #64ffda 0%, #00d9ff 100%);
            color: #0a192f;
            margin-left: auto;
            text-align: right;
            font-weight: 500;
        }
        
        .bot-message {
            background: rgba(100, 255, 218, 0.1);
            border: 1px solid rgba(100, 255, 218, 0.2);
            color: #e6f1ff;
            white-space: pre-wrap;
        }
        
        .chat-input-container {
            display: flex;
            gap: 8px;
            border-top: none;
        }
        
        #chatInput {
            flex: 1;
            padding: 10px;
            border: 1px solid rgba(100, 255, 218, 0.3);
            border-radius: 8px;
            font-size: 0.9em;
            background: rgba(10, 25, 47, 0.6);
            color: #e6f1ff;
        }
        
        #chatInput::placeholder {
            color: rgba(230, 241, 255, 0.5);
        }
        
        #sendBtn {
            background: linear-gradient(135deg, #64ffda 0%, #00d9ff 100%);
            color: #0a192f;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        #sendBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(100, 255, 218, 0.4);
        }
        
        #sendBtn:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }
        
        .row {
            margin-bottom: 20px;
        }
        
        .row-1 {
            display: grid;
            grid-template-columns: 1fr;
        }
        
        .row-2 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .row-3 {
            display: grid;
            grid-template-columns: 1fr;
        }
        
        .card {
            background: linear-gradient(135deg, rgba(20, 25, 45, 0.95) 0%, rgba(30, 20, 40, 0.95) 100%);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 24px;
            box-shadow:
                0 0 40px rgba(255, 0, 100, 0.2),
                0 0 20px rgba(255, 102, 0, 0.1),
                0 8px 32px rgba(0, 0, 0, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 102, 0, 0.3);
            min-height: 450px;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.1), transparent);
            transition: left 1.5s;
        }

        .card:hover::before {
            left: 100%;
        }
        
        .card h2 {
            color: #ffd700;
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 2px solid rgba(255, 102, 0, 0.4);
            padding-bottom: 12px;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            position: relative;
            z-index: 1;
        }

        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
        }

        .scrollable-table {
            max-height: 350px;
            overflow-y: auto;
            overflow-x: auto;
            border-radius: 8px;
            flex-grow: 1;
        }
        
        .scrollable-table::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        .scrollable-table::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
        }

        .scrollable-table::-webkit-scrollbar-thumb {
            background: rgba(0, 102, 204, 0.3);
            border-radius: 4px;
        }

        .scrollable-table::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 102, 204, 0.5);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            min-width: 500px;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 102, 0, 0.2);
        }

        th {
            background: linear-gradient(135deg, rgba(255, 0, 100, 0.95) 0%, rgba(255, 102, 0, 0.95) 100%);
            backdrop-filter: blur(10px);
            font-weight: 600;
            color: #ffd700;
            position: sticky;
            top: 0;
            z-index: 10;
            white-space: nowrap;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
        }

        td {
            font-size: 0.9em;
            color: #ffffff;
        }

        tr:hover {
            background: rgba(255, 102, 0, 0.1);
            transform: scale(1.01);
            transition: all 0.2s ease;
        }
        
        .rank-badge {
            display: inline-block;
            width: 30px;
            height: 30px;
            line-height: 30px;
            text-align: center;
            border-radius: 50%;
            font-weight: bold;
        }
        
        .rank-1 {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 50%, #FFD700 100%);
            color: #000;
            box-shadow:
                0 0 20px rgba(255, 215, 0, 0.8),
                0 0 40px rgba(255, 215, 0, 0.4),
                inset 0 0 10px rgba(255, 255, 255, 0.5);
            font-weight: 900;
            animation: pulse 2s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .rank-2 {
            background: linear-gradient(135deg, #E8E8E8 0%, #C0C0C0 50%, #E8E8E8 100%);
            color: #000;
            box-shadow:
                0 0 15px rgba(192, 192, 192, 0.6),
                inset 0 0 8px rgba(255, 255, 255, 0.4);
            font-weight: 800;
        }
        .rank-3 {
            background: linear-gradient(135deg, #E39A5A 0%, #CD7F32 50%, #E39A5A 100%);
            color: #fff;
            box-shadow:
                0 0 15px rgba(205, 127, 50, 0.6),
                inset 0 0 8px rgba(255, 255, 255, 0.3);
            font-weight: 800;
        }
        .rank-other {
            background: linear-gradient(135deg, rgba(255, 0, 100, 0.3) 0%, rgba(255, 102, 0, 0.3) 100%);
            color: #ffd700;
            border: 1px solid rgba(255, 102, 0, 0.5);
        }
        
        .bar-container {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }
        
        .player-name {
            min-width: 120px;
            font-weight: 600;
            color: #64ffda;
        }
        
        .bars {
            display: flex;
            flex: 1;
            gap: 2px;
            height: 25px;
        }
        
        .bar {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.8em;
            font-weight: bold;
            border-radius: 3px;
        }
        
        .bar-ace { background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); }
        .bar-eagle { background: linear-gradient(135deg, #f39c12 0%, #d68910 100%); }
        .bar-birdie { background: linear-gradient(135deg, #27ae60 0%, #229954 100%); }
        
        .legend {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            font-size: 0.9em;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
        }
        
        .loading {
            text-align: center;
            color: #64ffda;
            padding: 20px;
        }

        /* Podcast Modal Styles */
        .podcast-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 39, 0.95);
            backdrop-filter: blur(10px);
            animation: fadeIn 0.3s ease;
        }

        .podcast-modal-content {
            position: relative;
            background: linear-gradient(135deg, rgba(20, 25, 45, 0.95) 0%, rgba(30, 20, 40, 0.95) 100%);
            margin: 5% auto;
            padding: 30px;
            border: 2px solid #64ffda;
            border-radius: 20px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 40px rgba(100, 255, 218, 0.5), 0 0 80px rgba(0, 204, 255, 0.3);
            animation: slideIn 0.4s ease;
        }

        .podcast-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(100, 255, 218, 0.3);
        }

        .podcast-modal-header h2 {
            color: #64ffda;
            margin: 0;
            font-size: 1.6em;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .close-modal {
            color: #ff6699;
            font-size: 2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            line-height: 1;
        }

        .close-modal:hover {
            color: #ffee44;
            transform: rotate(90deg);
            text-shadow: 0 0 20px rgba(255, 238, 68, 0.8);
        }

        .podcast-episode {
            background: rgba(20, 25, 45, 0.6);
            padding: 20px;
            margin: 15px 0;
            border-radius: 15px;
            border: 1px solid rgba(100, 255, 218, 0.2);
            transition: all 0.3s;
        }

        .podcast-episode:hover {
            border-color: #64ffda;
            box-shadow: 0 0 20px rgba(100, 255, 218, 0.3);
            transform: translateX(5px);
        }

        .podcast-episode-title {
            color: #ffd700;
            font-size: 1.1em;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .podcast-episode-meta {
            color: #64ffda;
            font-size: 0.9em;
            margin-bottom: 15px;
            opacity: 0.8;
        }

        .podcast-play-btn {
            padding: 10px 25px;
            background: linear-gradient(135deg, #0066ff 0%, #00ccff 100%);
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .podcast-play-btn:hover {
            box-shadow: 0 0 25px rgba(0, 204, 255, 0.6);
            transform: scale(1.05);
        }

        .podcast-audio-player {
            margin-top: 15px;
            width: 100%;
        }

        .podcast-loading {
            text-align: center;
            color: #64ffda;
            font-size: 1.2em;
            padding: 40px;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            header h1 {
                font-size: 1.8em;
            }

            .logo {
                width: 60px;
                height: 60px;
            }
            
            .row-2 {
                grid-template-columns: 1fr;
            }
            
            .card {
                padding: 15px;
            }
            
            .card h2 {
                font-size: 1.1em;
            }
            
            table {
                font-size: 0.85em;
            }
            
            th, td {
                padding: 8px;
            }
            
            .player-name {
                min-width: 80px;
                font-size: 0.85em;
            }
            
            .chat-box.visible {
                height: 120px;
            }

            /* Fix mobile line graph height */
            .chart-container {
                height: 300px !important;
            }
        }
        
        @media (max-width: 480px) {
            header h1 {
                font-size: 2.5em;
            }
            
            table {
                font-size: 0.75em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo-container">
                <svg class="logo" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <ellipse cx="50" cy="70" rx="25" ry="8" fill="#444" opacity="0.6"/>
                    <rect x="48" y="30" width="4" height="40" fill="#666"/>
                    <circle cx="50" cy="30" r="2" fill="#888"/>
                    <line x1="35" y1="35" x2="35" y2="65" stroke="#888" stroke-width="1"/>
                    <line x1="42" y1="32" x2="42" y2="65" stroke="#888" stroke-width="1"/>
                    <line x1="50" y1="30" x2="50" y2="65" stroke="#888" stroke-width="1"/>
                    <line x1="58" y1="32" x2="58" y2="65" stroke="#888" stroke-width="1"/>
                    <line x1="65" y1="35" x2="65" y2="65" stroke="#888" stroke-width="1"/>
                    <g transform="translate(50, 15) rotate(15) translate(-50, -15)">
                        <path d="M 35 20 L 40 10 L 45 20 L 50 8 L 55 20 L 60 10 L 65 20 L 65 28 L 35 28 Z" 
                              fill="#64ffda" stroke="#00a896" stroke-width="1.5"/>
                        <circle cx="40" cy="10" r="2" fill="#ff6b6b"/>
                        <circle cx="50" cy="8" r="2.5" fill="#ff6b6b"/>
                        <circle cx="60" cy="10" r="2" fill="#ff6b6b"/>
                    </g>
                </svg>
            </div>
            <h1>
                <svg width="60" height="60" viewBox="0 0 100 100" style="flex-shrink: 0; filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.8));">
                    <!-- Pole -->
                    <rect x="48" y="10" width="4" height="80" fill="url(#poleGradient)"/>
                    <defs>
                        <linearGradient id="poleGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#ffd700;stop-opacity:1" />
                            <stop offset="50%" style="stop-color:#ff6600;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#ff0064;stop-opacity:1" />
                        </linearGradient>
                        <linearGradient id="basketGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                            <stop offset="0%" style="stop-color:#ff0064;stop-opacity:1" />
                            <stop offset="50%" style="stop-color:#ff6600;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#ffd700;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <!-- Base -->
                    <ellipse cx="50" cy="90" rx="15" ry="3" fill="#ff6600"/>
                    <!-- Basket rim -->
                    <ellipse cx="50" cy="25" rx="20" ry="4" fill="url(#basketGradient)"/>
                    <!-- Chains (3 sets) with glow -->
                    <line x1="40" y1="25" x2="40" y2="60" stroke="#ffd700" stroke-width="2"/>
                    <line x1="45" y1="25" x2="45" y2="62" stroke="#ff6600" stroke-width="2"/>
                    <line x1="50" y1="25" x2="50" y2="64" stroke="#ff0064" stroke-width="2"/>
                    <line x1="55" y1="25" x2="55" y2="62" stroke="#ff6600" stroke-width="2"/>
                    <line x1="60" y1="25" x2="60" y2="60" stroke="#ffd700" stroke-width="2"/>
                    <!-- Bottom basket -->
                    <path d="M 30 60 Q 50 75 70 60" fill="none" stroke="url(#basketGradient)" stroke-width="3"/>
                    <ellipse cx="50" cy="60" rx="20" ry="3" fill="url(#basketGradient)"/>
                </svg>
                ParSaveables
                <svg width="60" height="60" viewBox="0 0 100 100" style="flex-shrink: 0; filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.8));">
                    <!-- Pole -->
                    <rect x="48" y="10" width="4" height="80" fill="url(#poleGradient2)"/>
                    <defs>
                        <linearGradient id="poleGradient2" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#ffd700;stop-opacity:1" />
                            <stop offset="50%" style="stop-color:#ff6600;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#ff0064;stop-opacity:1" />
                        </linearGradient>
                        <linearGradient id="basketGradient2" x1="0%" y1="0%" x2="100%" y2="0%">
                            <stop offset="0%" style="stop-color:#ff0064;stop-opacity:1" />
                            <stop offset="50%" style="stop-color:#ff6600;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#ffd700;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <!-- Base -->
                    <ellipse cx="50" cy="90" rx="15" ry="3" fill="#ff6600"/>
                    <!-- Basket rim -->
                    <ellipse cx="50" cy="25" rx="20" ry="4" fill="url(#basketGradient2)"/>
                    <!-- Chains (3 sets) with glow -->
                    <line x1="40" y1="25" x2="40" y2="60" stroke="#ffd700" stroke-width="2"/>
                    <line x1="45" y1="25" x2="45" y2="62" stroke="#ff6600" stroke-width="2"/>
                    <line x1="50" y1="25" x2="50" y2="64" stroke="#ff0064" stroke-width="2"/>
                    <line x1="55" y1="25" x2="55" y2="62" stroke="#ff6600" stroke-width="2"/>
                    <line x1="60" y1="25" x2="60" y2="60" stroke="#ffd700" stroke-width="2"/>
                    <!-- Bottom basket -->
                    <path d="M 30 60 Q 50 75 70 60" fill="none" stroke="url(#basketGradient2)" stroke-width="3"/>
                    <ellipse cx="50" cy="60" rx="20" ry="3" fill="url(#basketGradient2)"/>
                </svg>
            </h1>

            <!-- Podcast Button (Top Right) -->
            <button id="podcastsBtn" onclick="openPodcastModal()" style="position: absolute; top: 20px; right: 20px; padding: 12px; font-size: 1.8em; border-radius: 50%; border: 2px solid #64ffda; background: linear-gradient(135deg, #0066ff 0%, #00ccff 100%); color: white; cursor: pointer; transition: all 0.3s; box-shadow: 0 0 20px rgba(0, 204, 255, 0.6); width: 60px; height: 60px; display: flex; align-items: center; justify-content: center;">
                üéôÔ∏è
            </button>

            <!-- Tab Navigation -->
            <div style="margin: 20px 0; display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
                <button id="seasonsTab" onclick="switchTab('seasons')" style="padding: 14px 36px; font-size: 1.1em; border-radius: 12px; border: 2px solid #ff6600; background: linear-gradient(135deg, #ff0064 0%, #ff6600 100%); color: white; cursor: pointer; font-weight: 700; transition: all 0.3s; box-shadow: 0 0 20px rgba(255, 102, 0, 0.6), 0 0 40px rgba(255, 0, 100, 0.3); text-transform: uppercase; letter-spacing: 1px;">
                    Seasons
                </button>
                <button id="tournamentsTab" onclick="switchTab('tournaments')" style="padding: 14px 36px; font-size: 1.1em; border-radius: 12px; border: 2px solid rgba(255, 102, 0, 0.4); background: rgba(20, 25, 45, 0.8); color: #ffd700; cursor: pointer; font-weight: 700; transition: all 0.3s; text-transform: uppercase; letter-spacing: 1px;">
                    Tournaments
                </button>
            </div>

            <!-- Event Selector -->
            <div style="margin: 15px 0;">
                <label for="eventSelect" id="eventLabel" style="font-size: 1.1em; margin-right: 10px; color: #ffd700; font-weight: 600; text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);">Season:</label>
                <select id="eventSelect" onchange="loadAllData()" style="padding: 10px 20px; font-size: 1em; border-radius: 10px; background: linear-gradient(135deg, rgba(20, 25, 45, 0.9) 0%, rgba(30, 20, 40, 0.9) 100%); color: #ffd700; border: 2px solid rgba(255, 102, 0, 0.5); cursor: pointer; font-weight: 600; box-shadow: 0 0 15px rgba(255, 102, 0, 0.3);">
                    <!-- Options will be populated dynamically -->
                </select>
            </div>
        </header>

        <!-- Podcast Modal -->
        <div id="podcastModal" class="podcast-modal" onclick="closePodcastModal(event)">
            <div class="podcast-modal-content" onclick="event.stopPropagation()">
                <div class="podcast-modal-header">
                    <h2>üéôÔ∏è Chain Reactions Podcast</h2>
                    <span class="close-modal" onclick="closePodcastModal()">&times;</span>
                </div>
                <div id="podcastList" class="podcast-loading">
                    Loading podcasts...
                </div>
            </div>
        </div>

        <div class="chat-section" id="chatSection">
            <div class="chat-box" id="chatBox"></div>
            <div class="chat-input-container">
                <input type="text" id="chatInput" placeholder="Ask a question about stats..." onkeypress="handleKeyPress(event)">
                <button id="sendBtn" onclick="sendMessage()">Send</button>
            </div>
        </div>

        <div class="row row-1">
            <div class="card">
                <h2 id="leaderboardTitle">üèÜ Season Leaderboard</h2>
                <div class="scrollable-table">
                    <div id="leaderboard" class="loading">Loading...</div>
                </div>
            </div>
        </div>

        <div class="row row-2">
            <div class="card">
                <h2>üéØ Aces/Eagles/Birdies</h2>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color bar-ace"></div>
                        <span>Aces</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color bar-eagle"></div>
                        <span>Eagles</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color bar-birdie"></div>
                        <span>Birdies</span>
                    </div>
                </div>
                <div class="scrollable-table">
                    <div id="birdieLeaders" class="loading">Loading...</div>
                </div>
            </div>

            <div class="card">
                <h2 id="coursesTableTitle">üèûÔ∏è Average Score by Course Tiers</h2>
                <div class="scrollable-table">
                    <div id="coursesTable" class="loading">Loading...</div>
                </div>
            </div>
        </div>

        <div class="row row-3">
            <div class="card">
                <h2 id="trendChartTitle">üìà Monthly Points Trend</h2>
                <div class="chart-container">
                    <canvas id="monthlyTrendChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        const SUPABASE_URL = 'https://bcovevbtcdsgzbrieiin.supabase.co';  // e.g., 'https://xxxxx.supabase.co'
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJjb3ZldmJ0Y2RzZ3picmllaWluIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA2MzA3OTEsImV4cCI6MjA3NjIwNjc5MX0.etzrLL8yw4n_NUdYnr_bdcrKphW67dYln8CjR54NSLA';  // Long string starting with 'eyJ...'
        const N8N_CHATBOT_URL = 'https://parsaveables-seasons.onrender.com/webhook/chatbot';  // e.g., 'http://localhost:5678/webhook/chatbot'

        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
        let monthlyTrendChart;
        let availableSeasons = [];
        let currentTab = 'seasons'; // Track current tab
        let availableEvents = []; // Store all events

        // Registered players list
        const REGISTERED_PLAYERS = [
            'Intern Line Cook',
            'Jabba the Putt',
            'Food Zaddy',
            'Jaguar',
            'Shogun',
            'BigBirdie',
            'Butter Cookie',
            'Cobra',
            'Bird',
            'Fireball',
            'Ace Brook',
            'ScarletSpeedster'
        ];

        // Display name mapper - converts database names to display names
        function getDisplayName(dbName) {
            if (dbName === 'Bird') return 'ü¶Ö';
            return dbName;
        }

        // Check if a player name is registered (case-insensitive)
        function isRegisteredPlayer(playerName) {
            return REGISTERED_PLAYERS.some(registeredName =>
                registeredName.toLowerCase() === playerName.toLowerCase()
            );
        }

        // Get the canonical registered player name (with correct casing)
        function getCanonicalPlayerName(playerName) {
            const match = REGISTERED_PLAYERS.find(registeredName =>
                registeredName.toLowerCase() === playerName.toLowerCase()
            );
            return match || playerName;
        }

        // Podcast Modal Functions
        let currentAudio = null;

        function openPodcastModal() {
            document.getElementById('podcastModal').style.display = 'block';
            loadPodcasts();
        }

        function closePodcastModal(event) {
            // Close only if clicking outside or on close button
            if (!event || event.target.id === 'podcastModal' || event.target.className === 'close-modal') {
                document.getElementById('podcastModal').style.display = 'none';
                // Stop any playing audio
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio = null;
                }
            }
        }

        async function loadPodcasts() {
            const podcastList = document.getElementById('podcastList');
            podcastList.innerHTML = '<div class="podcast-loading">Loading podcasts...</div>';

            try {
                // Fetch releases from GitHub
                const response = await fetch('https://api.github.com/repos/swarnimb/ParSaveables/releases');

                if (!response.ok) {
                    throw new Error('Failed to fetch podcasts');
                }

                const releases = await response.json();

                // Filter releases that have audio files
                const podcastReleases = releases.filter(release =>
                    release.assets && release.assets.some(asset => asset.name.endsWith('.mp3'))
                );

                if (podcastReleases.length === 0) {
                    podcastList.innerHTML = '<div class="podcast-loading">No podcasts available yet. Check back soon!</div>';
                    return;
                }

                // Display podcasts
                podcastList.innerHTML = '';
                podcastReleases.forEach((release, index) => {
                    const audioAsset = release.assets.find(asset => asset.name.endsWith('.mp3'));
                    if (audioAsset) {
                        const episodeDiv = createPodcastEpisode(release, audioAsset, index + 1);
                        podcastList.appendChild(episodeDiv);
                    }
                });

            } catch (error) {
                console.error('Error loading podcasts:', error);
                podcastList.innerHTML = '<div class="podcast-loading" style="color: #ff6699;">Failed to load podcasts. Please try again later.</div>';
            }
        }

        function createPodcastEpisode(release, audioAsset, episodeNumber) {
            const episodeDiv = document.createElement('div');
            episodeDiv.className = 'podcast-episode';

            // Episode title
            const title = document.createElement('div');
            title.className = 'podcast-episode-title';
            title.textContent = release.name || `Episode ${episodeNumber}`;

            // Meta info with duration estimate
            const meta = document.createElement('div');
            meta.className = 'podcast-episode-meta';
            const fileSize = (audioAsset.size / (1024 * 1024)).toFixed(1);
            // Estimate duration: ~1MB per minute for 128kbps MP3
            const estimatedDuration = Math.round(fileSize);
            meta.textContent = `‚è±Ô∏è ${estimatedDuration} min`;

            // Play button
            const playBtn = document.createElement('button');
            playBtn.className = 'podcast-play-btn';
            playBtn.textContent = '‚ñ∂Ô∏è Play';
            playBtn.onclick = () => playPodcast(audioAsset.browser_download_url, episodeDiv, playBtn);

            episodeDiv.appendChild(title);
            episodeDiv.appendChild(meta);
            episodeDiv.appendChild(playBtn);

            return episodeDiv;
        }

        function playPodcast(audioUrl, episodeDiv, playBtn) {
            // Stop any currently playing audio
            if (currentAudio) {
                currentAudio.pause();
                // Reset previous play button
                const prevBtns = document.querySelectorAll('.podcast-play-btn');
                prevBtns.forEach(btn => {
                    btn.textContent = '‚ñ∂Ô∏è Play';
                    btn.style.background = 'linear-gradient(135deg, #0066ff 0%, #00ccff 100%)';
                });
                // Remove previous audio players
                document.querySelectorAll('.podcast-audio-player').forEach(player => player.remove());
            }

            // Check if clicking same button
            if (currentAudio && currentAudio.src === audioUrl && !currentAudio.paused) {
                currentAudio.pause();
                playBtn.textContent = '‚ñ∂Ô∏è Play';
                playBtn.style.background = 'linear-gradient(135deg, #0066ff 0%, #00ccff 100%)';
                currentAudio = null;
                return;
            }

            // Create audio player element
            const audioPlayer = document.createElement('audio');
            audioPlayer.controls = true;
            audioPlayer.className = 'podcast-audio-player';
            audioPlayer.preload = 'metadata';
            audioPlayer.src = audioUrl;
            audioPlayer.style.width = '100%';
            audioPlayer.style.marginTop = '15px';
            audioPlayer.style.borderRadius = '8px';
            audioPlayer.style.outline = 'none';

            currentAudio = audioPlayer;
            episodeDiv.appendChild(audioPlayer);

            // Don't auto-play - let user click the audio player controls
            // This prevents mobile browser blocking
            playBtn.textContent = 'üéµ Playing';
            playBtn.style.background = 'linear-gradient(135deg, #00cc88 0%, #00ff99 100%)';
            playBtn.disabled = true;

            audioPlayer.onended = () => {
                playBtn.textContent = '‚ñ∂Ô∏è Play';
                playBtn.style.background = 'linear-gradient(135deg, #0066ff 0%, #00ccff 100%)';
                playBtn.disabled = false;
                currentAudio = null;
            };

            audioPlayer.onpause = () => {
                if (!audioPlayer.ended) {
                    playBtn.textContent = '‚ñ∂Ô∏è Resume';
                    playBtn.style.background = 'linear-gradient(135deg, #0066ff 0%, #00ccff 100%)';
                    playBtn.disabled = false;
                }
            };

            audioPlayer.onplay = () => {
                playBtn.textContent = 'üéµ Playing';
                playBtn.style.background = 'linear-gradient(135deg, #00cc88 0%, #00ff99 100%)';
                playBtn.disabled = true;
            };

            audioPlayer.onerror = (e) => {
                playBtn.textContent = '‚ùå Error';
                playBtn.style.background = 'linear-gradient(135deg, #666 0%, #999 100%)';
                playBtn.disabled = false;
                console.error('Audio loading error:', e);
                console.error('Audio URL:', audioUrl);
            };

            // Button doesn't control playback - just shows status
            // User clicks the audio player controls directly
            playBtn.onclick = null;
        }

        // Switch between Seasons and Tournaments tabs
        function switchTab(tab) {
            currentTab = tab;

            // Update tab button styles
            const seasonsBtn = document.getElementById('seasonsTab');
            const tournamentsBtn = document.getElementById('tournamentsTab');

            if (tab === 'seasons') {
                seasonsBtn.style.background = 'linear-gradient(135deg, #64ffda 0%, #00d9ff 100%)';
                seasonsBtn.style.color = '#0a192f';
                tournamentsBtn.style.background = 'rgba(100, 255, 218, 0.1)';
                tournamentsBtn.style.color = '#64ffda';
                document.getElementById('eventLabel').textContent = 'Season:';
                document.getElementById('leaderboardTitle').textContent = 'üèÜ Season Leaderboard';
                document.getElementById('coursesTableTitle').textContent = 'üèûÔ∏è Average Score by Course Tiers';
            } else {
                tournamentsBtn.style.background = 'linear-gradient(135deg, #64ffda 0%, #00d9ff 100%)';
                tournamentsBtn.style.color = '#0a192f';
                seasonsBtn.style.background = 'rgba(100, 255, 218, 0.1)';
                seasonsBtn.style.color = '#64ffda';
                document.getElementById('eventLabel').textContent = 'Tournament:';
                document.getElementById('leaderboardTitle').textContent = 'üèÜ Tournament Leaderboard';
                document.getElementById('coursesTableTitle').textContent = 'üèÅ Scores by Rounds';
            }

            // Load events for the selected tab
            loadEvents();
        }

        // Get selected event ID from dropdown
        function getSelectedEventId() {
            const select = document.getElementById('eventSelect');
            return select.value ? parseInt(select.value) : null;
        }

        // Load available events and populate dropdown based on current tab
        async function loadEvents() {
            const { data, error } = await supabase
                .from('events')
                .select('*')
                .eq('type', currentTab === 'seasons' ? 'season' : 'tournament')
                .eq('is_active', true)
                .order('year', { ascending: false });

            if (error) {
                console.error('Error loading events:', error);
                return;
            }

            availableEvents = data;

            // Populate dropdown
            const select = document.getElementById('eventSelect');
            select.innerHTML = '';

            if (availableEvents.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = currentTab === 'seasons' ? 'No seasons available' : 'No tournaments available';
                select.appendChild(option);

                // Clear all displays when no events available
                document.getElementById('leaderboard').innerHTML = '<p style="text-align: center; padding: 20px;">No ' + (currentTab === 'seasons' ? 'seasons' : 'tournaments') + ' available</p>';
                document.getElementById('birdieLeaders').innerHTML = '<p style="text-align: center; padding: 20px;">No data available</p>';
                document.getElementById('coursesTable').innerHTML = '<p style="text-align: center; padding: 20px;">No data available</p>';
                if (monthlyTrendChart) monthlyTrendChart.destroy();
                return;
            }

            availableEvents.forEach(event => {
                const option = document.createElement('option');
                option.value = event.id;
                option.textContent = event.name;
                select.appendChild(option);
            });

            // Select most recent event by default
            if (availableEvents.length > 0) {
                select.value = availableEvents[0].id;
            }

            // Load data for selected event
            loadAllData();
        }

        async function loadAllData() {
            await Promise.all([
                loadLeaderboard(),
                loadBirdieLeaders(),
                loadCoursesTable(),
                loadMonthlyTrend()
            ]);
        }

        async function loadLeaderboard() {
            const selectedEventId = getSelectedEventId();
            if (!selectedEventId) return;

            // Get rounds for selected event
            const { data: rounds, error: roundsError} = await supabase
                .from('rounds')
                .select('id')
                .eq('event_id', selectedEventId);

            if (roundsError) {
                document.getElementById('leaderboard').innerHTML = 'Error loading data';
                console.error('Rounds error:', roundsError);
                return;
            }

            const roundIds = rounds.map(r => r.id);
            if (roundIds.length === 0) {
                document.getElementById('leaderboard').innerHTML = '<p style="text-align: center; padding: 20px;">No data for this season</p>';
                return;
            }

            // Get player_rounds for these rounds
            const { data, error } = await supabase
                .from('player_rounds')
                .select('player_name, final_total, rank, round_id')
                .in('round_id', roundIds);

            if (error) {
                document.getElementById('leaderboard').innerHTML = 'Error loading data';
                console.error('Leaderboard error:', error);
                return;
            }

            // Filter for registered players only and collect all their rounds
            const playerRounds = {};
            data.forEach(round => {
                // Only count registered players (case-insensitive)
                if (!isRegisteredPlayer(round.player_name)) return;

                const canonicalName = getCanonicalPlayerName(round.player_name);
                if (!playerRounds[canonicalName]) {
                    playerRounds[canonicalName] = [];
                }
                playerRounds[canonicalName].push({
                    points: round.final_total || 0,
                    rank: round.rank
                });
            });

            // Calculate stats using only TOP 10 scores
            const playerStats = {};
            Object.entries(playerRounds).forEach(([name, rounds]) => {
                // Sort rounds by points (descending) and take top 10
                const sortedRounds = rounds.sort((a, b) => b.points - a.points);
                const top10Rounds = sortedRounds.slice(0, 10);

                playerStats[name] = {
                    points: top10Rounds.reduce((sum, r) => sum + r.points, 0),
                    rounds: rounds.length, // Total rounds played
                    countedRounds: top10Rounds.length, // Rounds counted (max 10)
                    wins: rounds.filter(r => r.rank === 1).length,
                    top3: rounds.filter(r => r.rank <= 3).length
                };
            });

            // SORT BY POINTS (descending)
            const leaderboard = Object.entries(playerStats)
                .map(([name, stats]) => ({ name, ...stats }))
                .sort((a, b) => b.points - a.points);

            let html = `<table><thead><tr><th>Rank</th><th>Player</th><th>Played</th><th>Counted</th><th>Points</th><th>Wins</th><th>Top 3</th></tr></thead><tbody>`;

            leaderboard.forEach((player, index) => {
                const rankClass = index === 0 ? 'rank-1' : index === 1 ? 'rank-2' : index === 2 ? 'rank-3' : 'rank-other';
                html += `<tr>
                    <td><span class="rank-badge ${rankClass}">${index + 1}</span></td>
                    <td><strong>${getDisplayName(player.name)}</strong></td>
                    <td>${player.rounds}</td>
                    <td>${player.countedRounds}</td>
                    <td><strong>${player.points.toFixed(1)}</strong></td>
                    <td>${player.wins}</td>
                    <td>${player.top3}</td>
                </tr>`;
            });
            html += '</tbody></table>';
            document.getElementById('leaderboard').innerHTML = html;
        }

        async function loadBirdieLeaders() {
            const selectedEventId = getSelectedEventId();
            if (!selectedEventId) return;

            // Get rounds for selected event
            const { data: rounds, error: roundsError } = await supabase
                .from('rounds')
                .select('id')
                .eq('event_id', selectedEventId);

            if (roundsError) {
                document.getElementById('birdieLeaders').innerHTML = 'Error loading data';
                return;
            }

            const roundIds = rounds.map(r => r.id);
            if (roundIds.length === 0) {
                document.getElementById('birdieLeaders').innerHTML = '<p style="text-align: center; padding: 20px;">No data for this season</p>';
                return;
            }

            const { data, error } = await supabase
                .from('player_rounds')
                .select('player_name, aces, eagles, birdies')
                .in('round_id', roundIds);

            if (error) {
                document.getElementById('birdieLeaders').innerHTML = 'Error loading data';
                return;
            }

            const playerStats = {};
            data.forEach(round => {
                // Only count registered players (case-insensitive)
                if (!isRegisteredPlayer(round.player_name)) return;

                const canonicalName = getCanonicalPlayerName(round.player_name);
                if (!playerStats[canonicalName]) {
                    playerStats[canonicalName] = { aces: 0, eagles: 0, birdies: 0 };
                }
                playerStats[canonicalName].aces += round.aces || 0;
                playerStats[canonicalName].eagles += round.eagles || 0;
                playerStats[canonicalName].birdies += round.birdies || 0;
            });

            // SORT BY TOTAL (descending)
            const sorted = Object.entries(playerStats)
                .map(([name, stats]) => ({ name, ...stats, total: stats.aces + stats.eagles + stats.birdies }))
                .sort((a, b) => b.total - a.total);

            const maxTotal = Math.max(...sorted.map(p => p.total), 1);

            let html = '<div style="padding: 10px;">';
            sorted.forEach(player => {
                const containerWidth = (player.total / maxTotal) * 100;
                html += `<div class="bar-container"><div class="player-name">${getDisplayName(player.name)}</div><div style="display: flex; align-items: center; flex: 1;"><div class="bars" style="width: ${containerWidth}%; max-width: 100%; display: flex; gap: 0;">`;
                if (player.aces > 0) html += `<div class="bar bar-ace" style="width: ${(player.aces / player.total) * 100}%; min-width: 30px;">${player.aces}</div>`;
                if (player.eagles > 0) html += `<div class="bar bar-eagle" style="width: ${(player.eagles / player.total) * 100}%; min-width: 30px;">${player.eagles}</div>`;
                if (player.birdies > 0) html += `<div class="bar bar-birdie" style="width: ${(player.birdies / player.total) * 100}%; min-width: 30px;">${player.birdies}</div>`;
                html += `</div><span style="margin-left: 10px; color: #64ffda; font-size: 0.9em; white-space: nowrap;">${player.total}</span></div></div>`;
            });
            html += '</div>';
            document.getElementById('birdieLeaders').innerHTML = html;
        }

        async function loadCoursesTable() {
            const selectedEventId = getSelectedEventId();
            if (!selectedEventId) return;

            const { data: rounds } = await supabase
                .from('rounds')
                .select('id, course_name, course_multiplier, date')
                .eq('event_id', selectedEventId)
                .order('date', { ascending: true });

            if (!rounds || rounds.length === 0) {
                document.getElementById('coursesTable').innerHTML = '<p style="text-align: center; padding: 20px;">No data available</p>';
                return;
            }

            const roundIds = rounds.map(r => r.id);
            const { data: playerRounds } = await supabase
                .from('player_rounds')
                .select('round_id, player_name, final_total')
                .in('round_id', roundIds);

            if (!playerRounds) return;

            // TOURNAMENT MODE: Show round-by-round scores
            if (currentTab === 'tournaments') {
                const playerStats = {};
                const playerTotalPoints = {};

                playerRounds.forEach(pr => {
                    // Only count registered players (case-insensitive)
                    if (!isRegisteredPlayer(pr.player_name)) return;

                    const canonicalName = getCanonicalPlayerName(pr.player_name);
                    if (!playerStats[canonicalName]) {
                        playerStats[canonicalName] = {};
                        playerTotalPoints[canonicalName] = 0;
                    }

                    playerStats[canonicalName][pr.round_id] = pr.final_total || 0;
                    playerTotalPoints[canonicalName] += pr.final_total || 0;
                });

                // Create table header with round numbers
                let html = `<table style="table-layout: fixed; width: 100%;"><thead><tr><th style="width: 20%;">Player</th>`;
                rounds.forEach((round, index) => {
                    html += `<th>Round ${index + 1}</th>`;
                });
                html += `</tr></thead><tbody>`;

                // Sort by total points descending
                const sortedPlayers = Object.keys(playerStats)
                    .sort((a, b) => playerTotalPoints[b] - playerTotalPoints[a]);

                sortedPlayers.forEach(player => {
                    html += `<tr><td><strong>${getDisplayName(player)}</strong></td>`;
                    rounds.forEach(round => {
                        const score = playerStats[player][round.id];
                        html += score ? `<td>${score.toFixed(1)}</td>` : `<td style="color: #555;">-</td>`;
                    });
                    html += `</tr>`;
                });

                html += '</tbody></table>';
                document.getElementById('coursesTable').innerHTML = html;

            } else {
                // SEASON MODE: Show tier-based averages
                const roundMap = {};
                rounds.forEach(r => { roundMap[r.id] = r.course_multiplier || 1.0; });

                const playerStats = {};
                const playerTotalPoints = {};

                playerRounds.forEach(pr => {
                    // Only count registered players (case-insensitive)
                    if (!isRegisteredPlayer(pr.player_name)) return;

                    const canonicalName = getCanonicalPlayerName(pr.player_name);
                    const tier = roundMap[pr.round_id];
                    if (!tier) return;
                    if (!playerStats[canonicalName]) {
                        playerStats[canonicalName] = {};
                        playerTotalPoints[canonicalName] = 0;
                    }
                    if (!playerStats[canonicalName][tier]) playerStats[canonicalName][tier] = { total: 0, count: 0 };
                    playerStats[canonicalName][tier].total += pr.final_total || 0;
                    playerStats[canonicalName][tier].count += 1;
                    playerTotalPoints[canonicalName] += pr.final_total || 0;
                });

                // Define all tiers
                const allTiers = [
                    { multiplier: 2.5, label: 'Elite' },
                    { multiplier: 2.0, label: 'Hard' },
                    { multiplier: 1.5, label: 'Medium' },
                    { multiplier: 1.0, label: 'Easy' }
                ];

                let html = `<table style="table-layout: fixed; width: 100%;"><thead><tr><th style="width: 25%;">Player</th>`;
                allTiers.forEach(tier => { html += `<th style="width: 18.75%;">${tier.label}</th>`; });
                html += `</tr></thead><tbody>`;

                // SORT BY TOTAL SEASON POINTS (descending)
                const sortedPlayers = Object.keys(playerStats)
                    .sort((a, b) => playerTotalPoints[b] - playerTotalPoints[a]);

                sortedPlayers.forEach(player => {
                    html += `<tr><td><strong>${getDisplayName(player)}</strong></td>`;
                    allTiers.forEach(tier => {
                        const stats = playerStats[player][tier.multiplier];
                        html += stats ? `<td>${(stats.total / stats.count).toFixed(1)}</td>` : `<td style="color: #555;">-</td>`;
                    });
                    html += `</tr>`;
                });
                html += '</tbody></table>';
                document.getElementById('coursesTable').innerHTML = html;
            }
        }

        async function loadMonthlyTrend() {
            const selectedEventId = getSelectedEventId();
            if (!selectedEventId) return;

            const { data: rounds } = await supabase
                .from('rounds')
                .select('id, date')
                .eq('event_id', selectedEventId)
                .order('date', { ascending: true });

            if (!rounds || rounds.length === 0) return;

            const roundIds = rounds.map(r => r.id);
            const { data: playerRounds } = await supabase
                .from('player_rounds')
                .select('round_id, player_name, final_total')
                .in('round_id', roundIds);

            if (!playerRounds) return;

            const roundDateMap = {};
            rounds.forEach(r => { roundDateMap[r.id] = r.date; });

            const colors = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40', '#FF6384', '#4DC9F6', '#8BC34A', '#7C4DFF'];

            // Check if we're viewing tournaments or seasons
            if (currentTab === 'tournaments') {
                // For tournaments: show round-by-round cumulative points
                document.getElementById('trendChartTitle').textContent = 'üìà Points Trend';

                // Create player data structure: player -> array of points per round
                const playerRoundData = {};
                rounds.forEach((round, roundIndex) => {
                    playerRounds.forEach(pr => {
                        if (!REGISTERED_PLAYERS.includes(pr.player_name)) return;
                        if (pr.round_id !== round.id) return;

                        if (!playerRoundData[pr.player_name]) {
                            playerRoundData[pr.player_name] = new Array(rounds.length).fill(0);
                        }
                        playerRoundData[pr.player_name][roundIndex] = pr.final_total || 0;
                    });
                });

                // Create round labels (Round 1, Round 2, etc.)
                const roundLabels = rounds.map((_, index) => `Round ${index + 1}`);

                const datasets = Object.entries(playerRoundData).map(([player, roundPoints], index) => {
                    // Calculate cumulative totals across rounds
                    let cumulative = 0;
                    const cumulativeData = roundPoints.map(points => {
                        cumulative += points;
                        return cumulative;
                    });

                    return {
                        label: getDisplayName(player),
                        data: cumulativeData,
                        borderColor: colors[index % colors.length],
                        backgroundColor: colors[index % colors.length] + '40',
                        tension: 0.3,
                        fill: false,
                        borderWidth: 2
                    };
                });

                const ctx = document.getElementById('monthlyTrendChart');
                if (monthlyTrendChart) monthlyTrendChart.destroy();
                monthlyTrendChart = new Chart(ctx, {
                    type: 'line',
                    data: { labels: roundLabels, datasets: datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { position: 'top', labels: { color: '#64ffda', font: { size: 12 } } } },
                        scales: {
                            y: { beginAtZero: true, title: { display: true, text: 'Points', color: '#64ffda' }, ticks: { color: '#e6f1ff' }, grid: { color: 'rgba(100, 255, 218, 0.1)' } },
                            x: { title: { display: true, text: 'Round', color: '#64ffda' }, ticks: { color: '#e6f1ff' }, grid: { color: 'rgba(100, 255, 218, 0.1)' } }
                        }
                    }
                });
            } else {
                // For seasons: show monthly cumulative points (existing logic)
                document.getElementById('trendChartTitle').textContent = 'üìà Monthly Points Trend';

                const playerMonthlyData = {};
                playerRounds.forEach(pr => {
                    // Only count registered players
                    if (!REGISTERED_PLAYERS.includes(pr.player_name)) return;

                    const date = roundDateMap[pr.round_id];
                    if (!date) return;
                    const month = date.substring(0, 7);
                    if (!playerMonthlyData[pr.player_name]) playerMonthlyData[pr.player_name] = {};
                    if (!playerMonthlyData[pr.player_name][month]) playerMonthlyData[pr.player_name][month] = 0;
                    playerMonthlyData[pr.player_name][month] += pr.final_total || 0;
                });

                const allMonths = [...new Set(Object.values(roundDateMap).map(d => d.substring(0, 7)))].sort();
                const datasets = Object.entries(playerMonthlyData).map(([player, months], index) => {
                    // Calculate cumulative totals
                    let cumulative = 0;
                    const cumulativeData = allMonths.map(month => {
                        cumulative += months[month] || 0;
                        return cumulative;
                    });

                    return {
                        label: getDisplayName(player),
                        data: cumulativeData,
                        borderColor: colors[index % colors.length],
                        backgroundColor: colors[index % colors.length] + '40',
                        tension: 0.3,
                        fill: false,
                        borderWidth: 2
                    };
                });

                const ctx = document.getElementById('monthlyTrendChart');
                if (monthlyTrendChart) monthlyTrendChart.destroy();
                monthlyTrendChart = new Chart(ctx, {
                    type: 'line',
                    data: { labels: allMonths, datasets: datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { position: 'top', labels: { color: '#64ffda', font: { size: 12 } } } },
                        scales: {
                            y: { beginAtZero: true, title: { display: true, text: 'Points', color: '#64ffda' }, ticks: { color: '#e6f1ff' }, grid: { color: 'rgba(100, 255, 218, 0.1)' } },
                            x: { title: { display: true, text: 'Month', color: '#64ffda' }, ticks: { color: '#e6f1ff' }, grid: { color: 'rgba(100, 255, 218, 0.1)' } }
                        }
                    }
                });
            }
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter') sendMessage();
        }

        async function sendMessage() {
            const input = document.getElementById('chatInput');
            const question = input.value.trim();
            if (!question) return;

            const chatBox = document.getElementById('chatBox');
            const chatSection = document.getElementById('chatSection');
            chatBox.classList.add('visible');
            chatSection.classList.add('expanded');

            addMessage(question, 'user');
            input.value = '';

            const sendBtn = document.getElementById('sendBtn');
            sendBtn.disabled = true;
            sendBtn.textContent = 'Thinking...';

            try {
                const response = await fetch(N8N_CHATBOT_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ question })
                });
                const data = await response.json();
                addMessage(data.answer || 'Sorry, I could not process that question.', 'bot');
            } catch (error) {
                console.error('Chat error:', error);
                addMessage('Error: Could not connect to chatbot.', 'bot');
            }

            sendBtn.disabled = false;
            sendBtn.textContent = 'Send';
        }

        function addMessage(text, type) {
            const chatBox = document.getElementById('chatBox');
            const message = document.createElement('div');
            message.className = `message ${type}-message`;
            message.style.whiteSpace = 'pre-wrap';
            message.textContent = text;
            chatBox.appendChild(message);
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        // Initialize: Load events first, then load data
        async function initialize() {
            await loadEvents();
        }

        initialize();
        setInterval(loadAllData, 300000); // Auto-refresh every 5 minutes
    </script>
</body>
</html>
