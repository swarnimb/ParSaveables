{
  "name": "ParSaveables Scorecard and Chat",
  "nodes": [
    {
      "parameters": {
        "jsCode": " // Get image URL from incoming webhook data\n  const imageUrl = $input.all()[0].json.body.attachments[0].url;\n\n  // Build the request body\n  const requestBody = {\n    model: \"claude-sonnet-4-5-20250929\",\n    max_tokens: 4096,\n    temperature: 0.3,\n    messages: [\n      {\n        role: \"user\",\n        content: [\n          {\n            type: \"text\",\n            text: \"Extract ALL data from this UDisc disc golf scorecard screenshot and return it as valid JSON.\\n\\nThe scorecard layout shows (top to bottom, left to right):\\n- Header area (top 1-2 lines): Look for 'course name' and 'layout name' - they may be on separate lines or the same line \\n- Hole identifiers (may be 1, 2, 2a, 2b, 3, A, B,4, 5... - extract EXACTLY as shown)\\n- Distance for each hole (in feet)\\n- Par for each hole \\n- Player names (may be truncated with '...')\\n- Each player's score for each hole on the scorecard \\n- Total strokes and score relative to par for each player\\n- Date, time, location, temperature, wind at bottom\\n\\nIMPORTANT: \\n1. If you see a player name that is a bird emoji, extract it as the text 'Bird' instead of trying to copy the emoji.\\n2. Be VERY CAREFUL when reading player names - they are critical for identification.\\n3. Common player names in this league: Jaguar, Shogun, BigBirdie, Cobra, Fireball, Ace Brook.\\n4. CRITICAL: Count the ACTUAL number of holes shown - it may be 9, 18, 20, or another number.\\n5.  Hole names may include letters (like 2a, 2b, 3a, A, B) - extract them EXACTLY as shown.\\n6. Each player must have scores for ALL holes shown on the scorecard.\\n\\n FINDING COURSE NAME AND LAYOUT: - Scan the top portion of the scorecard (first 1-3 lines)\\n- Course name is typically a recognizable course or park name\\n- Layout name often includes descriptors like 'Long', 'Short', '18-hole', or something unrecognizable that will follow the course name \\n- These may appear on the same line (separated) or consecutive lines \\n- Use context to identify which text represents the course vs layout \\n\\nScoring definitions (calculate based on par for each hole):\\n- ACE: Score of 1 (hole-in-one)\\n- EAGLE: 2 strokes under par and score of 2 or more\\n- BIRDIE: 1 stroke under par\\n- PAR: Score equals par\\n- BOGEY: 1 stroke over par\\n- DOUBLE BOGEY+: 2 or more strokes over par\\n\\nRequired JSON structure:\\n{\\n  \\\"courseName\\\": tring,\\n\\\"layoutName\\\": string,\\n  \\\"date\\\": string,\\n  \\\"time\\\": string,\\n  \\\"location\\\": string,\\n\\\"temperature\\\": string,\\n  \\\"wind\\\": string, n  \\\"holes\\\": [\\n    {\\n      \\\"hole\\\": string (EXACT hole identifier from scorecard - may be 1, 2, 2a, 2b, 3, A, B,4, 5...),\\n      \\\"distance\\\": number (in feet),\\n      \\\"par\\\": number\\n    }\\n  ],\\n\\\"players\\\": [\\n    {\\n      \\\"name\\\": string (keep '...' if truncated, or use 'Bird' for bird emojis),\\n \\\"totalStrokes\\\": number,\\n      \\\"totalScore\\\": number (relative to par, e.g., -6, +3),\\n      \\\"holeByHole\\\": [18 numbers],\\n      \\\"birdies\\\": number,\\n      \\\"eagles\\\": number,\\n      \\\"aces\\\": number,\\n      \\\"pars\\\": number,\\n      \\\"bogeys\\\": number,\\n \\\"doubleBogeys\\\": number\\n    }\\n  ]\\n}\\n\\nCRITICAL:\\n - The 'holes' array length must match the actual number of holes on the scorecard\\n - Each player's 'holeByHole' array length must equal the number of holes\\n - Extract hole identifiers EXACTLY as shown (including letters like '2a', '2b', '3a', 'A', 'B') \\n\\nFor each player, count their birdies/eagles/aces/pars/bogeys by comparing their score on each hole to that hole's par value.\\n\\nReturn ONLY valid JSON with no markdown code blocks or explanations.\"},\n          {\n            type: \"image\",\n            source: {\n              type: \"url\",\n              url: imageUrl\n            }\n          }\n        ]\n      }\n    ]\n  };\n\n  return {\n    json: {\n      body: requestBody,\n      headers: {\n        \"anthropic-version\": \"2023-06-01\"\n      }\n    }\n  };"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1904,
        -1024
      ],
      "id": "1cb8afea-f5cc-429d-9ba0-12df30f9f4f1",
      "name": "Build Claude Vision Request"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -1904,
        -832
      ],
      "id": "5806d8b8-4217-40ec-8a35-9a82cc73ee1b",
      "name": "No Operation, do nothing"
    },
    {
      "parameters": {
        "jsCode": "// Get the ranked player data from previous node\nconst roundData = $input.all()[0].json;\n\n// ===== COURSE DIFFICULTY TIERS =====\n// You can modify these tiers and courses as needed\nconst courseTiers = {\n  \"tier1\": {\n    multiplier: 1.0,\n    courses: [\"Wells Branch\", \"Lil G\", \"Armadillo Mini\"]\n  },\n  \"tier2\": {\n    multiplier: 1.5,\n    courses: [\"Zilker Park\", \"Live Oak\", \"Bartholomew Park\", \"Live Oak Brewing DGC\"]\n  },\n  \"tier3\": {\n    multiplier: 2.0,\n    courses: [\"Northtown Park\", \"Searight Park\", \"MetCenter\", \"Old Settler's\", \"Cat Hollow\", \"Circle C\", \"Williamson County\"]\n  },\n  \"tier4\": {\n    multiplier: 2.5,\n    courses: [\"East Metro\", \"Sprinkle Valley\", \"Roy G Guerrero\", \"Bible Ridge\", \"Flying Armadillo\", \"Harvey Penick\"]\n  }\n};\n\n// ===== RANK POINTS SYSTEM =====\nconst rankPoints = {\n  1: 10,\n  2: 7,\n  3: 5\n};\nconst defaultRankPoints = 2; // Everyone else who played\n\n// ===== PERFORMANCE BONUSES =====\nconst performancePoints = {\n  birdie: 1,\n  eagle: 3,\n  ace: 5\n};\n\n// ===== FIND COURSE MULTIPLIER =====\nfunction getCourseMultiplier(courseName) {\n  for (const tier in courseTiers) {\n    const tierData = courseTiers[tier];\n    // Check if course name matches (case-insensitive partial match)\n    const matchedCourse = tierData.courses.find(course => \n      courseName.toLowerCase().includes(course.toLowerCase()) ||\n      course.toLowerCase().includes(courseName.toLowerCase())\n    );\n    if (matchedCourse) {\n      return tierData.multiplier;\n    }\n  }\n  // Default to Tier 1 if course not found\n  console.log(`Warning: Course \"${courseName}\" not found in tiers. Using 1x multiplier.`);\n  return 1.0;\n}\n\n// ===== CALCULATE TIE-ADJUSTED RANK POINTS =====\nfunction calculateRankPoints(players) {\n  const rankPointsMap = {};\n  \n  let i = 0;\n  while (i < players.length) {\n    const currentRank = players[i].rank;\n    \n    // Find all players with this rank (ties)\n    let tiedPlayers = 1;\n    let j = i + 1;\n    while (j < players.length && players[j].rank === currentRank) {\n      tiedPlayers++;\n      j++;\n    }\n    \n    // Calculate average points for tied players\n    let totalPoints = 0;\n    for (let k = 0; k < tiedPlayers; k++) {\n      const rank = currentRank + k;\n      totalPoints += rankPoints[rank] || defaultRankPoints;\n    }\n    const avgPoints = totalPoints / tiedPlayers;\n    \n    // Assign average points to all tied players\n    for (let k = i; k < j; k++) {\n      rankPointsMap[k] = avgPoints;\n    }\n    \n    i = j;\n  }\n  \n  return rankPointsMap;\n}\n\n// ===== CALCULATE POINTS FOR EACH PLAYER =====\nconst courseMultiplier = getCourseMultiplier(roundData.courseName);\nconst rankPointsMap = calculateRankPoints(roundData.players);\n\nroundData.players.forEach((player, index) => {\n  // Base rank points (with tie averaging)\n  const baseRankPoints = rankPointsMap[index] || defaultRankPoints;\n  \n  // Performance bonuses\n  const birdiePoints = player.birdies * performancePoints.birdie;\n  const eaglePoints = player.eagles * performancePoints.eagle;\n  const acePoints = player.aces * performancePoints.ace;\n  \n  // Total before multiplier\n  const rawPoints = baseRankPoints + birdiePoints + eaglePoints + acePoints;\n  \n  // Apply course difficulty multiplier\n  const finalPoints = rawPoints * courseMultiplier;\n  \n  // Add point breakdown to player data\n  player.points = {\n    rankPoints: baseRankPoints,\n    birdiePoints: birdiePoints,\n    eaglePoints: eaglePoints,\n    acePoints: acePoints,\n    rawTotal: rawPoints,\n    courseMultiplier: courseMultiplier,\n    finalTotal: finalPoints\n  };\n});\n\n// Return complete round data with points\nreturn [{\n  json: {\n    roundInfo: {\n      courseName: roundData.courseName,\n      layoutName: roundData.layoutName,\n      date: roundData.date,\n      time: roundData.time,\n      location: roundData.location,\n      temperature: roundData.temperature,\n      wind: roundData.wind,\n      courseMultiplier: Number(courseMultiplier) // Force it to be a number\n    },\n    holes: roundData.holes,\n    players: roundData.players\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1232,
        -1024
      ],
      "id": "dace84c6-a050-4529-ac0f-1a45ad6ea154",
      "name": "Calculate Points"
    },
    {
      "parameters": {
        "jsCode": "// Get the response from Anthropic\n  const anthropicResponse = $input.all()[0].json;\n\n  // Extract the text content\n  const textContent = anthropicResponse.content[0].text;\n\n  // Remove markdown code blocks if present\n  let cleanJson = textContent.trim();\n  if (cleanJson.startsWith('```json')) {\n    cleanJson = cleanJson.replace(/```json\\n?/g, '').replace(/```\\n?/g, '');\n  }\n\n  // Parse the JSON\n  const parsedData = JSON.parse(cleanJson);\n\n  // ===== VALIDATION: Check for incomplete data =====\n  if (!parsedData.holes || parsedData.holes.length === 0) {\n    throw new Error('Scorecard extraction failed: No hole data found. Please ensure the image is a valid UDisc scorecard.');\n  }\n\n  if (!parsedData.players || parsedData.players.length === 0) {\n    throw new Error('Scorecard extraction failed: No player data found. Please ensure the image is a valid UDisc scorecard.');\n  }\n\n  // Check if all players have hole-by-hole data\n  const incompletePlayer = parsedData.players.find(p => !p.holeByHole || p.holeByHole.length ===\n  0);\n  if (incompletePlayer) {\n    throw new Error('Scorecard extraction failed: Player \"' + incompletePlayer.name + '\" has no hole-by-hole scores. Please ensure the scorecard image is clear and complete.');\n  }\n\n   // ===== NAME NORMALIZATION FUNCTION =====\n  function normalizePlayerName(name) {\n    // Trim whitespace\n    name = name.trim();\n\n    // Handle bird emoji player - Claude extracts as \"Bird\"\n    if (name.toLowerCase() === 'bird') {\n      return 'Bird';\n    }\n\n    // Handle truncated names\n    if (name.startsWith('Intern')) return 'Intern Line Cook';\n    if (name.startsWith('Jabba')) return 'Jabba the Putt';\n    if (name.startsWith('Food')) return 'Food Zaddy';\n\n    // List of valid registered players\n    const registeredPlayers = [\n      'Intern Line Cook',\n      'Jabba the Putt',\n      'Food Zaddy',\n      'Jaguar',\n      'Shogun',\n      'BigBirdie',\n      'Butter Cookie',\n      'Cobra',\n      'Bird',\n      'Fireball',\n      'Ace Brook',\n      'ScarletSpeedster'\n    ];\n\n    // Check for exact match (case-insensitive)\n    const exactMatch = registeredPlayers.find(p => p.toLowerCase() === name.toLowerCase());\n    if (exactMatch) {\n      return exactMatch;\n    }\n\n    // Levenshtein distance function for fuzzy matching\n    function levenshteinDistance(str1, str2) {\n      const m = str1.length;\n      const n = str2.length;\n      const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n\n      for (let i = 0; i <= m; i++) dp[i][0] = i;\n      for (let j = 0; j <= n; j++) dp[0][j] = j;\n\n      for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n          if (str1[i - 1].toLowerCase() === str2[j - 1].toLowerCase()) {\n            dp[i][j] = dp[i - 1][j - 1];\n          } else {\n            dp[i][j] = Math.min(\n              dp[i - 1][j] + 1,    // deletion\n              dp[i][j - 1] + 1,    // insertion\n              dp[i - 1][j - 1] + 1 // substitution\n            );\n          }\n        }\n      }\n      return dp[m][n];\n    }\n\n    // Find closest match using fuzzy matching\n    let closestMatch = null;\n    let smallestDistance = Infinity;\n\n    registeredPlayers.forEach(registeredName => {\n      const distance = levenshteinDistance(name, registeredName);\n\n      // Only consider it a match if distance is small relative to name length\n      // Threshold: max 2 character differences OR less than 30% of name length\n      const threshold = Math.max(2, Math.floor(registeredName.length * 0.3));\n\n      if (distance < smallestDistance && distance <= threshold) {\n        smallestDistance = distance;\n        closestMatch = registeredName;\n      }\n    });\n\n    if (closestMatch) {\n      console.log(`Fuzzy match: \"${name}\" -> \"${closestMatch}\" (distance: ${smallestDistance})`);\n      return closestMatch;\n    }\n\n    // If not matched, return as-is (will be filtered out later in dashboard)\n    return name;\n  }\n\n  // ===== NORMALIZE ALL PLAYER NAMES =====\n  parsedData.players.forEach(player => {\n    player.name = normalizePlayerName(player.name);\n  });\n\n  // Verify and recalculate player stats based on actual par values\n  const holes = parsedData.holes;\n\n  parsedData.players.forEach(player => {\n    let birdies = 0, eagles = 0, aces = 0, pars = 0, bogeys = 0, doubleBogeys = 0;\n\n    player.holeByHole.forEach((score, index) => {\n      // Safety check: Make sure the hole exists\n      if (!holes[index] || holes[index].par === undefined) {\n        console.log('Warning: Hole ' + (index + 1) + ' data missing. Skipping this hole for player' + player.name);\n        return; // Skip this hole\n      }\n\n      const par = holes[index].par;\n      const diff = score - par;\n\n      if (score === 1) {\n        aces++;\n      } else if (diff <= -2) {\n        eagles++;\n      } else if (diff === -1) {\n        birdies++;\n      } else if (diff === 0) {\n        pars++;\n      } else if (diff === 1) {\n        bogeys++;\n      } else if (diff >= 2) {\n        doubleBogeys++;\n      }\n    });\n\n    // Update the player's stats with verified counts\n    player.birdies = birdies;\n    player.eagles = eagles;\n    player.aces = aces;\n    player.pars = pars;\n    player.bogeys = bogeys;\n    player.doubleBogeys = doubleBogeys;\n  });\n\n  // Helper function to find the first birdie hole\n  function getFirstBirdieHole(player, holes) {\n    for (let i = 0; i < player.holeByHole.length; i++) {\n      // Safety check: Make sure hole data exists\n      if (!holes[i] || holes[i].par === undefined) {\n        continue; // Skip this hole\n      }\n\n      const score = player.holeByHole[i];\n      const par = holes[i].par;\n      if (score === par - 1 && score > 1) { // Birdie (not ace)\n        return i + 1; // Return hole number (1-indexed)\n      }\n    }\n    return 999; // No birdie found\n  }\n\n  // Apply tie-breaker logic and sort players\n  const players = parsedData.players;\n\n  players.sort((a, b) => {\n    // Primary: Total score (lower is better, e.g., -6 beats -4)\n    if (a.totalScore !== b.totalScore) {\n      return a.totalScore - b.totalScore;\n    }\n\n    // Tie-breaker 1: More birdies wins\n    if (a.birdies !== b.birdies) {\n      return b.birdies - a.birdies;\n    }\n\n    // Tie-breaker 2: More pars wins\n    if (a.pars !== b.pars) {\n      return b.pars - a.pars;\n    }\n\n    // Tie-breaker 3: Earlier first birdie wins\n    const aFirstBirdie = getFirstBirdieHole(a, holes);\n    const bFirstBirdie = getFirstBirdieHole(b, holes);\n\n    if (aFirstBirdie !== bFirstBirdie) {\n      return aFirstBirdie - bFirstBirdie;\n    }\n\n    // Tie-breaker 4: If all equal, they're tied\n    return 0;\n  });\n\n  // Assign ranks with proper tie handling\n  let currentRank = 1;\n  for (let i = 0; i < players.length; i++) {\n    if (i > 0) {\n      const prev = players[i - 1];\n      const curr = players[i];\n\n      // Check if tied with previous player\n      const isTied =\n        prev.totalScore === curr.totalScore &&\n        prev.birdies === curr.birdies &&\n        prev.pars === curr.pars &&\n        getFirstBirdieHole(prev, holes) === getFirstBirdieHole(curr, holes);\n\n      if (!isTied) {\n        currentRank = i + 1;\n      }\n    }\n\n    players[i].rank = currentRank;\n  }\n\n  // Return the complete structured data\n  return [{\n    json: {\n      courseName: parsedData.courseName,\n      layoutName: parsedData.layoutName,\n      date: parsedData.date,\n      time: parsedData.time,\n      location: parsedData.location,\n      temperature: parsedData.temperature,\n      wind: parsedData.wind,\n      holes: parsedData.holes,\n      players: players\n    }\n  }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1456,
        -1024
      ],
      "id": "f658a128-9fdc-41a4-95e0-b079e296db62",
      "name": "Clean and Rank Players"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "daa8d95f-2c76-4641-9fd7-decb2541f5e1",
              "leftValue": "={{$json[\"body\"][\"attachments\"][0][\"type\"]}}",
              "rightValue": "image",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -2128,
        -928
      ],
      "id": "2ca37f87-25d2-41bc-9df2-1deac87f1ee1",
      "name": "Check if Image"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "groupme-scorecard-incoming",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -2352,
        -928
      ],
      "id": "8dae960a-93b4-459b-83df-62e1b205d619",
      "name": "Receive Scorecard",
      "webhookId": "5497ebc3-4887-4f3a-9327-82d62b59b137"
    },
    {
      "parameters": {
        "tableId": "rounds",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "date",
              "fieldValue": "={{ $json.roundInfo.date }}"
            },
            {
              "fieldId": "time",
              "fieldValue": "={{ $json.roundInfo.time }}"
            },
            {
              "fieldId": "course_name",
              "fieldValue": "={{ $json.roundInfo.courseName }}"
            },
            {
              "fieldId": "layout_name",
              "fieldValue": "={{ $json.roundInfo.layoutName }}"
            },
            {
              "fieldId": "location",
              "fieldValue": "={{ $json.roundInfo.location }}"
            },
            {
              "fieldId": "temperature",
              "fieldValue": "={{ $json.roundInfo.temperature }}"
            },
            {
              "fieldId": "wind",
              "fieldValue": "={{ $json.roundInfo.wind }}"
            },
            {
              "fieldId": "course_multiplier",
              "fieldValue": "={{$json.roundInfo.courseMultiplier}}"
            },
            {
              "fieldId": "season",
              "fieldValue": "={{ new Date().getFullYear() }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -1008,
        -1024
      ],
      "id": "4a2f3caa-89dd-4412-ab5c-f3d0a7ddaefb",
      "name": "Save Round Info",
      "credentials": {
        "supabaseApi": {
          "id": "5lkoycUx6AqbcPeU",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "1baf46ef-c02b-43b0-ba8f-15b01e571105",
              "name": "round_id",
              "value": "={{ $json.id }}",
              "type": "string"
            },
            {
              "id": "ee80a643-6c8d-4198-8a22-3cdf359a974f",
              "name": "players",
              "value": "={{ $('Calculate Points').item.json.players }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -784,
        -1024
      ],
      "id": "fb0a3871-ea2d-4fa2-9149-49357bdea03a",
      "name": "Store Round ID"
    },
    {
      "parameters": {
        "tableId": "player_rounds",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "round_id",
              "fieldValue": "={{ $('Store Round ID').item.json.round_id }}"
            },
            {
              "fieldId": "player_name",
              "fieldValue": "={{ $json.name }}"
            },
            {
              "fieldId": "rank",
              "fieldValue": "={{ $json.rank }}"
            },
            {
              "fieldId": "total_strokes",
              "fieldValue": "={{ $json.totalStrokes }}"
            },
            {
              "fieldId": "total_score",
              "fieldValue": "={{ $json.totalScore }}"
            },
            {
              "fieldId": "birdies",
              "fieldValue": "={{ $json.birdies }}"
            },
            {
              "fieldId": "eagles",
              "fieldValue": "={{ $json.eagles }}"
            },
            {
              "fieldId": "aces",
              "fieldValue": "={{ $json.aces }}"
            },
            {
              "fieldId": "pars",
              "fieldValue": "={{ $json.pars }}"
            },
            {
              "fieldId": "bogeys",
              "fieldValue": "={{ $json.bogeys }}"
            },
            {
              "fieldId": "double_bogeys",
              "fieldValue": "={{ $json.doubleBogeys }}"
            },
            {
              "fieldId": "rank_points",
              "fieldValue": "={{ $json.points.rankPoints }}"
            },
            {
              "fieldId": "birdie_points",
              "fieldValue": "={{ $json.points.birdiePoints }}"
            },
            {
              "fieldId": "eagle_points",
              "fieldValue": "={{ $json.points.eaglePoints }}"
            },
            {
              "fieldId": "ace_points",
              "fieldValue": "={{ $json.points.acePoints }}"
            },
            {
              "fieldId": "raw_total",
              "fieldValue": "={{ $json.points.rawTotal }}"
            },
            {
              "fieldId": "final_total",
              "fieldValue": "={{ $json.points.finalTotal }}"
            },
            {
              "fieldId": "hole_by_hole",
              "fieldValue": "={{ JSON.stringify($json.holeByHole) }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -112,
        -1024
      ],
      "id": "50511fd2-4ea5-413c-b8fe-5649f5320083",
      "name": "Save Player Stats",
      "credentials": {
        "supabaseApi": {
          "id": "5lkoycUx6AqbcPeU",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "fieldToSplitOut": "players",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        -336,
        -1024
      ],
      "id": "fb559bb1-00bb-4cc8-9c10-ebd8547691df",
      "name": "Split Players into Rows"
    },
    {
      "parameters": {
        "jsCode": "const data = $input.all()[0].json;\n\n// Parse the players JSON string into an actual array\nconst players = JSON.parse(data.players);\n\n// Return the parsed data\nreturn [{\n  json: {\n    round_id: data.round_id,\n    players: players\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -560,
        -1024
      ],
      "id": "4cd1b8bc-e450-48bd-bc3a-e627fd964ef8",
      "name": "Parse Players Array"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "chatbot",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -2352,
        -272
      ],
      "id": "8b33c769-2085-4f9a-beda-6ead91707e38",
      "name": "Receive Chat Question",
      "webhookId": "9a8f9b3f-1d09-428d-943b-0beac37a080d"
    },
    {
      "parameters": {
        "jsCode": "const question = $input.all()[0].json.body.question;\n\n// Simple keyword detection to determine query type\nlet queryType = 'general';\nlet searchTerm = '';\n\nconst lowerQuestion = question.toLowerCase();\n\n// Detect query type\nif (lowerQuestion.includes('leaderboard') || lowerQuestion.includes('standings') || lowerQuestion.includes('winning')) {\n  queryType = 'leaderboard';\n} else if (lowerQuestion.includes('stats for') || lowerQuestion.includes('stats on') || lowerQuestion.includes('player')) {\n  queryType = 'player_stats';\n  \n  // Extract player name - look for text after \"for\" or \"on\"\n  let nameMatch = question.match(/(?:for|on)\\s+(.+?)$/i);\n  if (nameMatch && nameMatch[1]) {\n    searchTerm = nameMatch[1].trim();\n  }\n} else if (lowerQuestion.includes('course') || lowerQuestion.includes('at ')) {\n  queryType = 'course_stats';\n} else if (lowerQuestion.includes('round') || lowerQuestion.includes('game') || lowerQuestion.includes('recent')) {\n  queryType = 'recent_rounds';\n}\n\nconsole.log('Question:', question);\nconsole.log('Query Type:', queryType);\nconsole.log('Search Term:', searchTerm);\n\nreturn [{\n  json: {\n    question: question,\n    queryType: queryType,\n    searchTerm: searchTerm\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2128,
        -272
      ],
      "id": "7b4ef7cb-df77-463e-a970-d2ae3cbd09d5",
      "name": "Determine Query Type"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.queryType }}",
                    "rightValue": "leaderboard",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "77cfb6ba-4a4c-4377-ab94-9818ddc2fb10"
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "de2dda77-fc57-4121-92d6-68bb81441546",
                    "leftValue": "={{ $json.queryType }}",
                    "rightValue": "player_stats",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "0fa5d94d-d124-4ac9-b179-38080cabbe4d",
                    "leftValue": "={{ $json.queryType }}",
                    "rightValue": "course_stats",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "e41b1e47-af82-4a8e-8f8e-527f21bc0c11",
                    "leftValue": "={{ $json.queryType }}",
                    "rightValue": "recent_rounds",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        -1904,
        -320
      ],
      "id": "e6885238-1236-4b76-a477-241484d80220",
      "name": "Route by Query Type"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "player_rounds",
        "returnAll": true,
        "filterType": "none"
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -1680,
        -608
      ],
      "id": "6ffd06c7-8d72-4422-8780-9c3a8e33bdc8",
      "name": "Get Leaderboard Data",
      "credentials": {
        "supabaseApi": {
          "id": "5lkoycUx6AqbcPeU",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "player_rounds",
        "returnAll": true,
        "filters": {
          "conditions": [
            {
              "keyName": "player_name",
              "condition": "ilike",
              "keyValue": "=%{{ $json.searchTerm }}%"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -1680,
        -416
      ],
      "id": "a8efd44a-c625-4b6a-899a-402f2b468609",
      "name": "Get Player Stats",
      "credentials": {
        "supabaseApi": {
          "id": "5lkoycUx6AqbcPeU",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "rounds",
        "returnAll": true,
        "filterType": "none"
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -1680,
        -128
      ],
      "id": "27109f94-68a8-43bd-b8c9-750d8dfb267d",
      "name": "Get Course Stats",
      "credentials": {
        "supabaseApi": {
          "id": "5lkoycUx6AqbcPeU",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "rounds",
        "limit": 10,
        "filterType": "none"
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -1680,
        64
      ],
      "id": "e290da4d-e477-469e-a797-5e5817717c6e",
      "name": "Get Recent Rounds",
      "credentials": {
        "supabaseApi": {
          "id": "5lkoycUx6AqbcPeU",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "numberInputs": 5
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -1456,
        -320
      ],
      "id": "cfd23440-2fdc-45b8-a320-60c1a2b41ba6",
      "name": "Merge All Routes"
    },
    {
      "parameters": {
        "jsCode": "// Get the original question\nconst question = $('Determine Query Type').item.json.question;\n\n// Get all the data from Supabase queries\nconst allData = $input.all();\n\n// Combine all query results\nlet combinedData = [];\nallData.forEach(item => {\n  if (item.json && Array.isArray(item.json)) {\n    combinedData = combinedData.concat(item.json);\n  } else if (item.json) {\n    combinedData.push(item.json);\n  }\n});\n\n// Prepare context for Claude\nreturn [{\n  json: {\n    question: question,\n    data: combinedData,\n    dataCount: combinedData.length\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1232,
        -272
      ],
      "id": "59b418ca-cfaf-4ec8-bb18-74f28e99d172",
      "name": "Prepare Data for Claude"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.anthropic.com/v1/messages",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            },
            {
              "name": "content-type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "={{ $json.model }}"
            },
            {
              "name": "max_tokens",
              "value": "={{ $json.max_tokens }}"
            },
            {
              "name": "messages",
              "value": "={{ $json.messages }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -784,
        -272
      ],
      "id": "221564ea-6b02-4bd5-8298-91e64d005a53",
      "name": "Generate Answer",
      "credentials": {
        "httpHeaderAuth": {
          "id": "W3bky3N85AFDTH1o",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get Claude's response\nconst claudeResponse = $input.all()[0].json;\n\n// Extract the text from Claude's response\nconst answer = claudeResponse.content[0].text;\n\nreturn [{\n  json: {\n    answer: answer\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -560,
        -272
      ],
      "id": "0369087e-bbd3-42e4-b83c-f762b6bc020a",
      "name": "Extract Answer"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"answer\": $json.answer } }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              },
              {
                "name": "Access-Control-Allow-Methods",
                "value": "POST, GET, OPTIONS"
              },
              {
                "name": "Access-Control-Allow-Headers",
                "value": "Content-Type"
              }
            ]
          }
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        -336,
        -272
      ],
      "id": "3a8dcd30-6361-4186-8761-a21aebe0b033",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "jsCode": "const question = $input.item.json.question;\nconst data = $input.item.json.data;\n\nconst requestBody = {\n  model: \"claude-sonnet-4-20250514\",\n  max_tokens: 2000,\n  messages: [\n    {\n      role: \"user\",\n      content: `You are a disc golf season statistics assistant. Answer the user's question based on the data provided.\n\nUser Question: ${question}\n\nAvailable Data:\n${JSON.stringify(data, null, 2)}\n\nFORMATTING INSTRUCTIONS:\n- Keep responses concise and scannable\n- Use bullet points (•) for lists\n- Use numbered lists (1., 2., 3.) when showing rankings\n- Use line breaks to separate sections\n- For player stats, format as: \"Stat Name: Value\"\n- Highlight key numbers and metrics\n- Don't repeat the question in your answer\n- Don't use unnecessary filler words like \"Based on the data...\" or \"According to...\"\n- Get straight to the answer\n\nEXAMPLE FORMATS:\n\nFor leaderboards:\n1. Player Name - XXX points\n2. Player Name - XXX points\n3. Player Name - XXX points\n\nFor player stats:\n**Player Name Stats:**\n- Total Points: XXX\n- Rounds Played: X\n- Average: XX.X\n- Wins: X\n- Top 3 Finishes: X\n\nFor courses:\n**Courses Played:**\n- Course Name (Tier X.X) - Avg XX points\n- Course Name (Tier X.X) - Avg XX points\n\nProvide a clear, well-formatted answer using the patterns above. If the data is empty, say \"No data available for this query.\"`\n    }\n  ]\n};\n\nreturn {\n  json: requestBody\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1008,
        -272
      ],
      "id": "9090c6d2-67d2-4173-8fef-9a17f08fac6b",
      "name": "Build Claude Request"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.anthropic.com/v1/messages",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "anthropic-version",
              "value": "={{ $json.headers[\"anthropic-version\"] }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1680,
        -1024
      ],
      "id": "232a3fcd-5059-404b-9f7d-2e28b78f337c",
      "name": "Call Claude Vision API",
      "credentials": {
        "httpHeaderAuth": {
          "id": "W3bky3N85AFDTH1o",
          "name": "Header Auth account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Clean and Rank Players": {
      "main": [
        [
          {
            "node": "Calculate Points",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check if Image": {
      "main": [
        [
          {
            "node": "Build Claude Vision Request",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Operation, do nothing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Receive Scorecard": {
      "main": [
        [
          {
            "node": "Check if Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Points": {
      "main": [
        [
          {
            "node": "Save Round Info",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Round Info": {
      "main": [
        [
          {
            "node": "Store Round ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Round ID": {
      "main": [
        [
          {
            "node": "Parse Players Array",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Players into Rows": {
      "main": [
        [
          {
            "node": "Save Player Stats",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Players Array": {
      "main": [
        [
          {
            "node": "Split Players into Rows",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Receive Chat Question": {
      "main": [
        [
          {
            "node": "Determine Query Type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Determine Query Type": {
      "main": [
        [
          {
            "node": "Route by Query Type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route by Query Type": {
      "main": [
        [
          {
            "node": "Get Leaderboard Data",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Player Stats",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Course Stats",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Recent Rounds",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge All Routes",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Get Leaderboard Data": {
      "main": [
        [
          {
            "node": "Merge All Routes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Player Stats": {
      "main": [
        [
          {
            "node": "Merge All Routes",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Get Course Stats": {
      "main": [
        [
          {
            "node": "Merge All Routes",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "Get Recent Rounds": {
      "main": [
        [
          {
            "node": "Merge All Routes",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "Merge All Routes": {
      "main": [
        [
          {
            "node": "Prepare Data for Claude",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Data for Claude": {
      "main": [
        [
          {
            "node": "Build Claude Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Answer": {
      "main": [
        [
          {
            "node": "Extract Answer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Answer": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Claude Request": {
      "main": [
        [
          {
            "node": "Generate Answer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Claude Vision Request": {
      "main": [
        [
          {
            "node": "Call Claude Vision API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Claude Vision API": {
      "main": [
        [
          {
            "node": "Clean and Rank Players",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false,
    "errorWorkflow": "6E99OzAj0odpizeQ"
  },
  "versionId": "84f39b1a-c19a-47ed-ac17-97abde5f8fac",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "ff978110d07511b571b07f446e27923b856b4d0f922c99965ce226875ac45ce1"
  },
  "id": "6E99OzAj0odpizeQ",
  "tags": []
}